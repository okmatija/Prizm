//
// This file was autogenerated.
//

#module_parameters(LINK_STATIC := false, IMGUI_USE_BGRA_PACKED_COLOR := true);

#if OS == .WINDOWS {
    #if LINK_STATIC {
        user32 :: #foreign_system_library "user32";
        imgui :: #foreign_library,no_dll "./win/static/imgui";
    } else {
        imgui :: #foreign_library "./win/dll/imgui";
    }
}
#if OS == .LINUX {
    #if LINK_STATIC {
        imgui :: #foreign_library,no_dll "./linux/static/imgui";
    } else {
        imgui :: #foreign_library "./linux/imgui";
    }
}

make_ImVec2 :: inline (a: float, b: float) -> ImVec2 {
    v: ImVec2 = ---;
    v.x = a;
    v.y = b;
    return v;
}

make_ImVec4 :: inline (a: float, b: float, c: float, d: float) -> ImVec4 {
    v: ImVec4 = ---;
    v.x = a;
    v.y = b;
    v.z = c;
    v.w = d;
    return v;
}

operator + :: inline (a: ImVec2, b: ImVec2) -> ImVec2 {
    return make_ImVec2(a.x + b.x, a.y + b.y);
}

TreeNode :: (fmt: string, args: ..Any) -> bool {
    fmt_z := tprint("%\0", fmt);
    txt := tprint(fmt_z, ..args);
    return TreeNode(txt.data);
}

TextColored :: (col: ImVec4, fmt: string, args: .. Any) {
    PushStyleColor(.Text, col);
    fmt_z := tprint("%\0", fmt);
    txt := tprint(fmt_z, ..args);
    Text(txt.data);
    PopStyleColor();
}

#if Preprocessor_Defines.USE_BGRA_PACKED_COLOR {
    IM_COL32_R_SHIFT :: 16;
    IM_COL32_G_SHIFT :: 8;
    IM_COL32_B_SHIFT :: 0;
    IM_COL32_A_SHIFT :: 24;
    IM_COL32_A_MASK  :: 0xFF000000;
} else {
    IM_COL32_R_SHIFT  ::  0;
    IM_COL32_G_SHIFT  ::  8;
    IM_COL32_B_SHIFT  ::  16;
    IM_COL32_A_SHIFT  ::  24;
    IM_COL32_A_MASK   ::  0xFF000000;
}
// This is a C preprocessor macro, should it be a Jai macro?
make_col32 :: (R : u32, G: u32, B: u32, A: u32) -> u32 {
    return cast(u32)((A<<IM_COL32_A_SHIFT) | (B<<IM_COL32_B_SHIFT) | 
        (G<<IM_COL32_G_SHIFT) | (R<<IM_COL32_R_SHIFT));
}
make_col32 :: (c: ImVec4) -> u32 {
    return make_col32(xx(c.x * 255), xx(c.y * 255), xx(c.z * 255), xx(c.w * 255));
}



#scope_file

#import "Basic";
// TODO: these manual types shouldn't be necessary
size_t   :: u64;
FILE     :: struct { opaque: *void; }
FLT_MIN  :: 0h00800000;
FLT_MAX  :: 0h7F7FFFFF;

check_size :: ($T: Type, expected_size_in_bytes: int, loc := #caller_location) {
    size_of_struct := size_of(T);
    Compiler :: #import "Compiler";
    if size_of_struct != expected_size_in_bytes {
        msg := tprint("expected struct '%' to be % bytes, but it was % instead.", T, expected_size_in_bytes, size_of_struct);
        Compiler.compiler_report(msg, loc=loc);
    }
}

#scope_export
ImDrawListSharedData :: struct {
}
// #run check_size(ImDrawListSharedData, 0);

ImFontBuilderIO :: struct {
}
// #run check_size(ImFontBuilderIO, 0);

Context :: struct {
}
// #run check_size(Context, 0);

NavInput :: s32;

ImTextureID :: *void;

ID :: u32;

InputTextCallback :: #type (a0: *InputTextCallbackData) -> s32 #c_call;

SizeCallback :: #type (a0: *SizeCallbackData) -> void #c_call;

MemAllocFunc :: #type (a0: size_t, a1: *void) -> *void #c_call;

MemFreeFunc :: #type (a0: *void, a1: *void) -> void #c_call;

ImWchar16 :: u16;

ImWchar32 :: u32;

ImWchar :: ImWchar16;

ImS8 :: s8;

ImU8 :: u8;

ImS16 :: s16;

ImU16 :: u16;

ImS32 :: s32;

ImU32 :: u32;

ImS64 :: s64;

ImU64 :: u64;

ImVec2 :: struct {
    x: float;
    y: float;
    /* (jaicc: omitted inline function)
    operator[] :: (this: *ImVec2, idx: size_t) -> float #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    operator[] :: (this: *ImVec2, idx: size_t) -> *float #cpp_method {
    }
    */

}
// #run check_size(ImVec2, 8);

ImVec4 :: struct {
    x: float;
    y: float;
    z: float;
    w: float;
}
// #run check_size(ImVec4, 16);

// ImGui :: struct { // this namespace was flattened by '--flatten-namespace'
    CreateContext :: (shared_font_atlas: *ImFontAtlas = null) -> *Context #foreign imgui "?CreateContext@ImGui@@YAPEAUImGuiContext@@PEAUImFontAtlas@@@Z";
    DestroyContext :: (ctx: *Context = null) -> void #foreign imgui "?DestroyContext@ImGui@@YAXPEAUImGuiContext@@@Z";
    GetCurrentContext :: () -> *Context #foreign imgui "?GetCurrentContext@ImGui@@YAPEAUImGuiContext@@XZ";
    SetCurrentContext :: (ctx: *Context) -> void #foreign imgui "?SetCurrentContext@ImGui@@YAXPEAUImGuiContext@@@Z";
    GetIO :: () -> *IO #foreign imgui "?GetIO@ImGui@@YAAEAUImGuiIO@@XZ";
    GetStyle :: () -> *Style #foreign imgui "?GetStyle@ImGui@@YAAEAUImGuiStyle@@XZ";
    NewFrame :: () -> void #foreign imgui "?NewFrame@ImGui@@YAXXZ";
    EndFrame :: () -> void #foreign imgui "?EndFrame@ImGui@@YAXXZ";
    Render :: () -> void #foreign imgui "?Render@ImGui@@YAXXZ";
    GetDrawData :: () -> *ImDrawData #foreign imgui "?GetDrawData@ImGui@@YAPEAUImDrawData@@XZ";
    ShowDemoWindow :: (p_open: *bool = null) -> void #foreign imgui "?ShowDemoWindow@ImGui@@YAXPEA_N@Z";
    ShowMetricsWindow :: (p_open: *bool = null) -> void #foreign imgui "?ShowMetricsWindow@ImGui@@YAXPEA_N@Z";
    ShowAboutWindow :: (p_open: *bool = null) -> void #foreign imgui "?ShowAboutWindow@ImGui@@YAXPEA_N@Z";
    ShowStyleEditor :: (ref: *Style = null) -> void #foreign imgui "?ShowStyleEditor@ImGui@@YAXPEAUImGuiStyle@@@Z";
    ShowStyleSelector :: (label: *u8) -> bool #foreign imgui "?ShowStyleSelector@ImGui@@YA_NPEBD@Z";
    ShowFontSelector :: (label: *u8) -> void #foreign imgui "?ShowFontSelector@ImGui@@YAXPEBD@Z";
    ShowUserGuide :: () -> void #foreign imgui "?ShowUserGuide@ImGui@@YAXXZ";
    GetVersion :: () -> *u8 #foreign imgui "?GetVersion@ImGui@@YAPEBDXZ";
    StyleColorsDark :: (dst: *Style = null) -> void #foreign imgui "?StyleColorsDark@ImGui@@YAXPEAUImGuiStyle@@@Z";
    StyleColorsLight :: (dst: *Style = null) -> void #foreign imgui "?StyleColorsLight@ImGui@@YAXPEAUImGuiStyle@@@Z";
    StyleColorsClassic :: (dst: *Style = null) -> void #foreign imgui "?StyleColorsClassic@ImGui@@YAXPEAUImGuiStyle@@@Z";
    Begin :: (name: *u8, p_open: *bool = null, flags: WindowFlags = .None) -> bool #foreign imgui "?Begin@ImGui@@YA_NPEBDPEA_NH@Z";
    End :: () -> void #foreign imgui "?End@ImGui@@YAXXZ";
    BeginChild :: (str_id: *u8, size: ImVec2 = ImVec2.{0,0}, border: bool = false, flags: WindowFlags = .None) -> bool {
        BeginChild_internal :: (str_id: *u8, size: *ImVec2, border: bool, flags: WindowFlags) -> bool #foreign imgui "?BeginChild@ImGui@@YA_NPEBDAEBUImVec2@@_NH@Z";
        return BeginChild_internal(str_id, *size, border, flags);
    }
    BeginChild :: (id: ID, size: ImVec2 = ImVec2.{0,0}, border: bool = false, flags: WindowFlags = .None) -> bool {
        BeginChild_internal :: (id: ID, size: *ImVec2, border: bool, flags: WindowFlags) -> bool #foreign imgui "?BeginChild@ImGui@@YA_NIAEBUImVec2@@_NH@Z";
        return BeginChild_internal(id, *size, border, flags);
    }
    EndChild :: () -> void #foreign imgui "?EndChild@ImGui@@YAXXZ";
    IsWindowAppearing :: () -> bool #foreign imgui "?IsWindowAppearing@ImGui@@YA_NXZ";
    IsWindowCollapsed :: () -> bool #foreign imgui "?IsWindowCollapsed@ImGui@@YA_NXZ";
    IsWindowFocused :: (flags: FocusedFlags = .None) -> bool #foreign imgui "?IsWindowFocused@ImGui@@YA_NH@Z";
    IsWindowHovered :: (flags: HoveredFlags = .None) -> bool #foreign imgui "?IsWindowHovered@ImGui@@YA_NH@Z";
    GetWindowDrawList :: () -> *ImDrawList #foreign imgui "?GetWindowDrawList@ImGui@@YAPEAUImDrawList@@XZ";
    GetWindowDpiScale :: () -> float #foreign imgui "?GetWindowDpiScale@ImGui@@YAMXZ";
    GetWindowPos :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetWindowPos@ImGui@@YA?AUImVec2@@XZ";
    GetWindowSize :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetWindowSize@ImGui@@YA?AUImVec2@@XZ";
    GetWindowWidth :: () -> float #foreign imgui "?GetWindowWidth@ImGui@@YAMXZ";
    GetWindowHeight :: () -> float #foreign imgui "?GetWindowHeight@ImGui@@YAMXZ";
    GetWindowViewport :: () -> *Viewport #foreign imgui "?GetWindowViewport@ImGui@@YAPEAUImGuiViewport@@XZ";
    SetNextWindowPos :: (pos: ImVec2, cond: Cond = .None, pivot: ImVec2 = ImVec2.{0,0}) {
        SetNextWindowPos_internal :: (pos: *ImVec2, cond: Cond, pivot: *ImVec2) -> void #foreign imgui "?SetNextWindowPos@ImGui@@YAXAEBUImVec2@@H0@Z";
        SetNextWindowPos_internal(*pos, cond, *pivot);
    }
    SetNextWindowSize :: (size: ImVec2, cond: Cond = .None) {
        SetNextWindowSize_internal :: (size: *ImVec2, cond: Cond) -> void #foreign imgui "?SetNextWindowSize@ImGui@@YAXAEBUImVec2@@H@Z";
        SetNextWindowSize_internal(*size, cond);
    }
    SetNextWindowSizeConstraints :: (size_min: ImVec2, size_max: ImVec2, custom_callback: SizeCallback = null, custom_callback_data: *void = null) {
        SetNextWindowSizeConstraints_internal :: (size_min: *ImVec2, size_max: *ImVec2, custom_callback: SizeCallback, custom_callback_data: *void) -> void #foreign imgui "?SetNextWindowSizeConstraints@ImGui@@YAXAEBUImVec2@@0P6AXPEAUImGuiSizeCallbackData@@@ZPEAX@Z";
        SetNextWindowSizeConstraints_internal(*size_min, *size_max, custom_callback, custom_callback_data);
    }
    SetNextWindowContentSize :: (size: ImVec2) {
        SetNextWindowContentSize_internal :: (size: *ImVec2) -> void #foreign imgui "?SetNextWindowContentSize@ImGui@@YAXAEBUImVec2@@@Z";
        SetNextWindowContentSize_internal(*size);
    }
    SetNextWindowCollapsed :: (collapsed: bool, cond: Cond = .None) -> void #foreign imgui "?SetNextWindowCollapsed@ImGui@@YAX_NH@Z";
    SetNextWindowFocus :: () -> void #foreign imgui "?SetNextWindowFocus@ImGui@@YAXXZ";
    SetNextWindowBgAlpha :: (alpha: float) -> void #foreign imgui "?SetNextWindowBgAlpha@ImGui@@YAXM@Z";
    SetNextWindowViewport :: (viewport_id: ID) -> void #foreign imgui "?SetNextWindowViewport@ImGui@@YAXI@Z";
    SetWindowPos :: (pos: ImVec2, cond: Cond = .None) {
        SetWindowPos_internal :: (pos: *ImVec2, cond: Cond) -> void #foreign imgui "?SetWindowPos@ImGui@@YAXAEBUImVec2@@H@Z";
        SetWindowPos_internal(*pos, cond);
    }
    SetWindowSize :: (size: ImVec2, cond: Cond = .None) {
        SetWindowSize_internal :: (size: *ImVec2, cond: Cond) -> void #foreign imgui "?SetWindowSize@ImGui@@YAXAEBUImVec2@@H@Z";
        SetWindowSize_internal(*size, cond);
    }
    SetWindowCollapsed :: (collapsed: bool, cond: Cond = .None) -> void #foreign imgui "?SetWindowCollapsed@ImGui@@YAX_NH@Z";
    SetWindowFocus :: () -> void #foreign imgui "?SetWindowFocus@ImGui@@YAXXZ";
    SetWindowFontScale :: (scale: float) -> void #foreign imgui "?SetWindowFontScale@ImGui@@YAXM@Z";
    SetWindowPos :: (name: *u8, pos: ImVec2, cond: Cond = .None) {
        SetWindowPos_internal :: (name: *u8, pos: *ImVec2, cond: Cond) -> void #foreign imgui "?SetWindowPos@ImGui@@YAXPEBDAEBUImVec2@@H@Z";
        SetWindowPos_internal(name, *pos, cond);
    }
    SetWindowSize :: (name: *u8, size: ImVec2, cond: Cond = .None) {
        SetWindowSize_internal :: (name: *u8, size: *ImVec2, cond: Cond) -> void #foreign imgui "?SetWindowSize@ImGui@@YAXPEBDAEBUImVec2@@H@Z";
        SetWindowSize_internal(name, *size, cond);
    }
    SetWindowCollapsed :: (name: *u8, collapsed: bool, cond: Cond = .None) -> void #foreign imgui "?SetWindowCollapsed@ImGui@@YAXPEBD_NH@Z";
    SetWindowFocus :: (name: *u8) -> void #foreign imgui "?SetWindowFocus@ImGui@@YAXPEBD@Z";
    GetContentRegionAvail :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetContentRegionAvail@ImGui@@YA?AUImVec2@@XZ";
    GetContentRegionMax :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetContentRegionMax@ImGui@@YA?AUImVec2@@XZ";
    GetWindowContentRegionMin :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetWindowContentRegionMin@ImGui@@YA?AUImVec2@@XZ";
    GetWindowContentRegionMax :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetWindowContentRegionMax@ImGui@@YA?AUImVec2@@XZ";
    GetWindowContentRegionWidth :: () -> float #foreign imgui "?GetWindowContentRegionWidth@ImGui@@YAMXZ";
    GetScrollX :: () -> float #foreign imgui "?GetScrollX@ImGui@@YAMXZ";
    GetScrollY :: () -> float #foreign imgui "?GetScrollY@ImGui@@YAMXZ";
    SetScrollX :: (scroll_x: float) -> void #foreign imgui "?SetScrollX@ImGui@@YAXM@Z";
    SetScrollY :: (scroll_y: float) -> void #foreign imgui "?SetScrollY@ImGui@@YAXM@Z";
    GetScrollMaxX :: () -> float #foreign imgui "?GetScrollMaxX@ImGui@@YAMXZ";
    GetScrollMaxY :: () -> float #foreign imgui "?GetScrollMaxY@ImGui@@YAMXZ";
    SetScrollHereX :: (center_x_ratio: float = 0.5) -> void #foreign imgui "?SetScrollHereX@ImGui@@YAXM@Z";
    SetScrollHereY :: (center_y_ratio: float = 0.5) -> void #foreign imgui "?SetScrollHereY@ImGui@@YAXM@Z";
    SetScrollFromPosX :: (local_x: float, center_x_ratio: float = 0.5) -> void #foreign imgui "?SetScrollFromPosX@ImGui@@YAXMM@Z";
    SetScrollFromPosY :: (local_y: float, center_y_ratio: float = 0.5) -> void #foreign imgui "?SetScrollFromPosY@ImGui@@YAXMM@Z";
    PushFont :: (font: *ImFont) -> void #foreign imgui "?PushFont@ImGui@@YAXPEAUImFont@@@Z";
    PopFont :: () -> void #foreign imgui "?PopFont@ImGui@@YAXXZ";
    PushStyleColor :: (idx: Col, col: ImU32) -> void #foreign imgui "?PushStyleColor@ImGui@@YAXHI@Z";
    PushStyleColor :: (idx: Col, col: ImVec4) {
        PushStyleColor_internal :: (idx: Col, col: *ImVec4) -> void #foreign imgui "?PushStyleColor@ImGui@@YAXHAEBUImVec4@@@Z";
        PushStyleColor_internal(idx, *col);
    }
    PopStyleColor :: (count: s32 = 1) -> void #foreign imgui "?PopStyleColor@ImGui@@YAXH@Z";
    PushStyleVar :: (idx: StyleVar, val: float) -> void #foreign imgui "?PushStyleVar@ImGui@@YAXHM@Z";
    PushStyleVar :: (idx: StyleVar, val: ImVec2) {
        PushStyleVar_internal :: (idx: StyleVar, val: *ImVec2) -> void #foreign imgui "?PushStyleVar@ImGui@@YAXHAEBUImVec2@@@Z";
        PushStyleVar_internal(idx, *val);
    }
    PopStyleVar :: (count: s32 = 1) -> void #foreign imgui "?PopStyleVar@ImGui@@YAXH@Z";
    PushAllowKeyboardFocus :: (allow_keyboard_focus: bool) -> void #foreign imgui "?PushAllowKeyboardFocus@ImGui@@YAX_N@Z";
    PopAllowKeyboardFocus :: () -> void #foreign imgui "?PopAllowKeyboardFocus@ImGui@@YAXXZ";
    PushButtonRepeat :: (repeat: bool) -> void #foreign imgui "?PushButtonRepeat@ImGui@@YAX_N@Z";
    PopButtonRepeat :: () -> void #foreign imgui "?PopButtonRepeat@ImGui@@YAXXZ";
    PushItemWidth :: (item_width: float) -> void #foreign imgui "?PushItemWidth@ImGui@@YAXM@Z";
    PopItemWidth :: () -> void #foreign imgui "?PopItemWidth@ImGui@@YAXXZ";
    SetNextItemWidth :: (item_width: float) -> void #foreign imgui "?SetNextItemWidth@ImGui@@YAXM@Z";
    CalcItemWidth :: () -> float #foreign imgui "?CalcItemWidth@ImGui@@YAMXZ";
    PushTextWrapPos :: (wrap_local_pos_x: float = 0.0) -> void #foreign imgui "?PushTextWrapPos@ImGui@@YAXM@Z";
    PopTextWrapPos :: () -> void #foreign imgui "?PopTextWrapPos@ImGui@@YAXXZ";
    GetFont :: () -> *ImFont #foreign imgui "?GetFont@ImGui@@YAPEAUImFont@@XZ";
    GetFontSize :: () -> float #foreign imgui "?GetFontSize@ImGui@@YAMXZ";
    GetFontTexUvWhitePixel :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetFontTexUvWhitePixel@ImGui@@YA?AUImVec2@@XZ";
    GetColorU32 :: (idx: Col, alpha_mul: float = 1.0) -> ImU32 #foreign imgui "?GetColorU32@ImGui@@YAIHM@Z";
    GetColorU32 :: (col: ImVec4) -> ImU32 {
        GetColorU32_internal :: (col: *ImVec4) -> ImU32 #foreign imgui "?GetColorU32@ImGui@@YAIAEBUImVec4@@@Z";
        return GetColorU32_internal(*col);
    }
    GetColorU32 :: (col: ImU32) -> ImU32 #foreign imgui "?GetColorU32@ImGui@@YAII@Z";
    GetStyleColorVec4 :: (idx: Col) -> *ImVec4 #foreign imgui "?GetStyleColorVec4@ImGui@@YAAEBUImVec4@@H@Z";
    Separator :: () -> void #foreign imgui "?Separator@ImGui@@YAXXZ";
    SameLine :: (offset_from_start_x: float = 0.0, spacing: float = -1.0) -> void #foreign imgui "?SameLine@ImGui@@YAXMM@Z";
    NewLine :: () -> void #foreign imgui "?NewLine@ImGui@@YAXXZ";
    Spacing :: () -> void #foreign imgui "?Spacing@ImGui@@YAXXZ";
    Dummy :: (size: ImVec2) {
        Dummy_internal :: (size: *ImVec2) -> void #foreign imgui "?Dummy@ImGui@@YAXAEBUImVec2@@@Z";
        Dummy_internal(*size);
    }
    Indent :: (indent_w: float = 0.0) -> void #foreign imgui "?Indent@ImGui@@YAXM@Z";
    Unindent :: (indent_w: float = 0.0) -> void #foreign imgui "?Unindent@ImGui@@YAXM@Z";
    BeginGroup :: () -> void #foreign imgui "?BeginGroup@ImGui@@YAXXZ";
    EndGroup :: () -> void #foreign imgui "?EndGroup@ImGui@@YAXXZ";
    GetCursorPos :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetCursorPos@ImGui@@YA?AUImVec2@@XZ";
    GetCursorPosX :: () -> float #foreign imgui "?GetCursorPosX@ImGui@@YAMXZ";
    GetCursorPosY :: () -> float #foreign imgui "?GetCursorPosY@ImGui@@YAMXZ";
    SetCursorPos :: (local_pos: ImVec2) {
        SetCursorPos_internal :: (local_pos: *ImVec2) -> void #foreign imgui "?SetCursorPos@ImGui@@YAXAEBUImVec2@@@Z";
        SetCursorPos_internal(*local_pos);
    }
    SetCursorPosX :: (local_x: float) -> void #foreign imgui "?SetCursorPosX@ImGui@@YAXM@Z";
    SetCursorPosY :: (local_y: float) -> void #foreign imgui "?SetCursorPosY@ImGui@@YAXM@Z";
    GetCursorStartPos :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetCursorStartPos@ImGui@@YA?AUImVec2@@XZ";
    GetCursorScreenPos :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetCursorScreenPos@ImGui@@YA?AUImVec2@@XZ";
    SetCursorScreenPos :: (pos: ImVec2) {
        SetCursorScreenPos_internal :: (pos: *ImVec2) -> void #foreign imgui "?SetCursorScreenPos@ImGui@@YAXAEBUImVec2@@@Z";
        SetCursorScreenPos_internal(*pos);
    }
    AlignTextToFramePadding :: () -> void #foreign imgui "?AlignTextToFramePadding@ImGui@@YAXXZ";
    GetTextLineHeight :: () -> float #foreign imgui "?GetTextLineHeight@ImGui@@YAMXZ";
    GetTextLineHeightWithSpacing :: () -> float #foreign imgui "?GetTextLineHeightWithSpacing@ImGui@@YAMXZ";
    GetFrameHeight :: () -> float #foreign imgui "?GetFrameHeight@ImGui@@YAMXZ";
    GetFrameHeightWithSpacing :: () -> float #foreign imgui "?GetFrameHeightWithSpacing@ImGui@@YAMXZ";
    PushID :: (str_id: *u8) -> void #foreign imgui "?PushID@ImGui@@YAXPEBD@Z";
    PushID :: (str_id: string) {
        PushID_internal :: (str_id_begin: *u8, str_id_end: *u8) -> void #foreign imgui "?PushID@ImGui@@YAXPEBD0@Z";
        PushID_internal(str_id.data, str_id.data + str_id.count);
    }
    PushID :: (ptr_id: *void) -> void #foreign imgui "?PushID@ImGui@@YAXPEBX@Z";
    PushID :: (int_id: s32) -> void #foreign imgui "?PushID@ImGui@@YAXH@Z";
    PopID :: () -> void #foreign imgui "?PopID@ImGui@@YAXXZ";
    GetID :: (str_id: *u8) -> ID #foreign imgui "?GetID@ImGui@@YAIPEBD@Z";
    GetID :: (str_id: string) -> ID {
        GetID_internal :: (str_id_begin: *u8, str_id_end: *u8) -> ID #foreign imgui "?GetID@ImGui@@YAIPEBD0@Z";
        return GetID_internal(str_id.data, str_id.data + str_id.count);
    }
    GetID :: (ptr_id: *void) -> ID #foreign imgui "?GetID@ImGui@@YAIPEBX@Z";
    TextUnformatted :: (text: string) {
        TextUnformatted_internal :: (text: *u8, text_end: *u8) -> void #foreign imgui "?TextUnformatted@ImGui@@YAXPEBD0@Z";
        TextUnformatted_internal(text.data, text.data + text.count);
    }
    Text :: (fmt: *u8, __args: ..Any) -> void #foreign imgui "?Text@ImGui@@YAXPEBDZZ";
    /* (jaicc: omitted function with valist)
    TextV :: (fmt: *u8, args: va_list) -> void #foreign imgui "?TextV@ImGui@@YAXPEBDPEAD@Z";
    */

    TextColored :: (col: ImVec4, fmt: *u8, __args: ..Any) {
        TextColored_internal :: (col: *ImVec4, fmt: *u8, __args: ..Any) -> void #foreign imgui "?TextColored@ImGui@@YAXAEBUImVec4@@PEBDZZ";
        TextColored_internal(*col, fmt);
    }
    /* (jaicc: omitted function with valist)
    TextColoredV :: (col: ImVec4, fmt: *u8, args: va_list) {
        TextColoredV_internal :: (col: *ImVec4, fmt: *u8, args: va_list) -> void #foreign imgui "?TextColoredV@ImGui@@YAXAEBUImVec4@@PEBDPEAD@Z";
        TextColoredV_internal(*col, fmt, args);
    }
    */

    TextDisabled :: (fmt: *u8, __args: ..Any) -> void #foreign imgui "?TextDisabled@ImGui@@YAXPEBDZZ";
    /* (jaicc: omitted function with valist)
    TextDisabledV :: (fmt: *u8, args: va_list) -> void #foreign imgui "?TextDisabledV@ImGui@@YAXPEBDPEAD@Z";
    */

    TextWrapped :: (fmt: *u8, __args: ..Any) -> void #foreign imgui "?TextWrapped@ImGui@@YAXPEBDZZ";
    /* (jaicc: omitted function with valist)
    TextWrappedV :: (fmt: *u8, args: va_list) -> void #foreign imgui "?TextWrappedV@ImGui@@YAXPEBDPEAD@Z";
    */

    LabelText :: (label: *u8, fmt: *u8, __args: ..Any) -> void #foreign imgui "?LabelText@ImGui@@YAXPEBD0ZZ";
    /* (jaicc: omitted function with valist)
    LabelTextV :: (label: *u8, fmt: *u8, args: va_list) -> void #foreign imgui "?LabelTextV@ImGui@@YAXPEBD0PEAD@Z";
    */

    BulletText :: (fmt: *u8, __args: ..Any) -> void #foreign imgui "?BulletText@ImGui@@YAXPEBDZZ";
    /* (jaicc: omitted function with valist)
    BulletTextV :: (fmt: *u8, args: va_list) -> void #foreign imgui "?BulletTextV@ImGui@@YAXPEBDPEAD@Z";
    */

    Button :: (label: *u8, size: ImVec2 = ImVec2.{0,0}) -> bool {
        Button_internal :: (label: *u8, size: *ImVec2) -> bool #foreign imgui "?Button@ImGui@@YA_NPEBDAEBUImVec2@@@Z";
        return Button_internal(label, *size);
    }
    SmallButton :: (label: *u8) -> bool #foreign imgui "?SmallButton@ImGui@@YA_NPEBD@Z";
    InvisibleButton :: (str_id: *u8, size: ImVec2, flags: ButtonFlags = .None) -> bool {
        InvisibleButton_internal :: (str_id: *u8, size: *ImVec2, flags: ButtonFlags) -> bool #foreign imgui "?InvisibleButton@ImGui@@YA_NPEBDAEBUImVec2@@H@Z";
        return InvisibleButton_internal(str_id, *size, flags);
    }
    ArrowButton :: (str_id: *u8, dir: Dir) -> bool #foreign imgui "?ArrowButton@ImGui@@YA_NPEBDH@Z";
    Image :: (user_texture_id: ImTextureID, size: ImVec2, uv0: ImVec2 = ImVec2.{0,0}, uv1: ImVec2 = ImVec2.{1,1}, tint_col: ImVec4 = ImVec4.{1,1,1,1}, border_col: ImVec4 = ImVec4.{0,0,0,0}) {
        Image_internal :: (user_texture_id: ImTextureID, size: *ImVec2, uv0: *ImVec2, uv1: *ImVec2, tint_col: *ImVec4, border_col: *ImVec4) -> void #foreign imgui "?Image@ImGui@@YAXPEAXAEBUImVec2@@11AEBUImVec4@@2@Z";
        Image_internal(user_texture_id, *size, *uv0, *uv1, *tint_col, *border_col);
    }
    ImageButton :: (user_texture_id: ImTextureID, size: ImVec2, uv0: ImVec2 = ImVec2.{0,0}, uv1: ImVec2 = ImVec2.{1,1}, frame_padding: s32 = -1, bg_col: ImVec4 = ImVec4.{0,0,0,0}, tint_col: ImVec4 = ImVec4.{1,1,1,1}) -> bool {
        ImageButton_internal :: (user_texture_id: ImTextureID, size: *ImVec2, uv0: *ImVec2, uv1: *ImVec2, frame_padding: s32, bg_col: *ImVec4, tint_col: *ImVec4) -> bool #foreign imgui "?ImageButton@ImGui@@YA_NPEAXAEBUImVec2@@11HAEBUImVec4@@2@Z";
        return ImageButton_internal(user_texture_id, *size, *uv0, *uv1, frame_padding, *bg_col, *tint_col);
    }
    Checkbox :: (label: *u8, v: *bool) -> bool #foreign imgui "?Checkbox@ImGui@@YA_NPEBDPEA_N@Z";
    CheckboxFlags :: (label: *u8, flags: *s32, flags_value: s32) -> bool #foreign imgui "?CheckboxFlags@ImGui@@YA_NPEBDPEAHH@Z";
    CheckboxFlags :: (label: *u8, flags: *u32, flags_value: u32) -> bool #foreign imgui "?CheckboxFlags@ImGui@@YA_NPEBDPEAII@Z";
    RadioButton :: (label: *u8, active: bool) -> bool #foreign imgui "?RadioButton@ImGui@@YA_NPEBD_N@Z";
    RadioButton :: (label: *u8, v: *s32, v_button: s32) -> bool #foreign imgui "?RadioButton@ImGui@@YA_NPEBDPEAHH@Z";
    ProgressBar :: (fraction: float, size_arg: ImVec2 = ImVec2.{-FLT_MIN,0}, overlay: *u8 = null) {
        ProgressBar_internal :: (fraction: float, size_arg: *ImVec2, overlay: *u8) -> void #foreign imgui "?ProgressBar@ImGui@@YAXMAEBUImVec2@@PEBD@Z";
        ProgressBar_internal(fraction, *size_arg, overlay);
    }
    Bullet :: () -> void #foreign imgui "?Bullet@ImGui@@YAXXZ";
    BeginCombo :: (label: *u8, preview_value: *u8, flags: ComboFlags = .None) -> bool #foreign imgui "?BeginCombo@ImGui@@YA_NPEBD0H@Z";
    EndCombo :: () -> void #foreign imgui "?EndCombo@ImGui@@YAXXZ";
    Combo :: (label: *u8, current_item: *s32, items: **u8, items_count: s32, popup_max_height_in_items: s32 = -1) -> bool #foreign imgui "?Combo@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z";
    Combo :: (label: *u8, current_item: *s32, items_separated_by_zeros: *u8, popup_max_height_in_items: s32 = -1) -> bool #foreign imgui "?Combo@ImGui@@YA_NPEBDPEAH0H@Z";
    Combo :: (label: *u8, current_item: *s32, items_getter: #type (a0: *void, a1: s32, a2: **u8) -> bool #c_call, data: *void, items_count: s32, popup_max_height_in_items: s32 = -1) -> bool #foreign imgui "?Combo@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z";
    DragFloat :: (label: *u8, v: *float, v_speed: float = 1.0, v_min: float = 0.0, v_max: float = 0.0, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui "?DragFloat@ImGui@@YA_NPEBDPEAMMMM0H@Z";
    DragFloat2 :: (label: *u8, v: *[2] float, v_speed: float = 1.0, v_min: float = 0.0, v_max: float = 0.0, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui "?DragFloat2@ImGui@@YA_NPEBDQEAMMMM0H@Z";
    DragFloat3 :: (label: *u8, v: *[3] float, v_speed: float = 1.0, v_min: float = 0.0, v_max: float = 0.0, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui "?DragFloat3@ImGui@@YA_NPEBDQEAMMMM0H@Z";
    DragFloat4 :: (label: *u8, v: *[4] float, v_speed: float = 1.0, v_min: float = 0.0, v_max: float = 0.0, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui "?DragFloat4@ImGui@@YA_NPEBDQEAMMMM0H@Z";
    DragFloatRange2 :: (label: *u8, v_current_min: *float, v_current_max: *float, v_speed: float = 1.0, v_min: float = 0.0, v_max: float = 0.0, format: *u8 = "%.3f", format_max: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui "?DragFloatRange2@ImGui@@YA_NPEBDPEAM1MMM00H@Z";
    DragInt :: (label: *u8, v: *s32, v_speed: float = 1.0, v_min: s32 = 0, v_max: s32 = 0, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui "?DragInt@ImGui@@YA_NPEBDPEAHMHH0H@Z";
    DragInt2 :: (label: *u8, v: *[2] s32, v_speed: float = 1.0, v_min: s32 = 0, v_max: s32 = 0, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui "?DragInt2@ImGui@@YA_NPEBDQEAHMHH0H@Z";
    DragInt3 :: (label: *u8, v: *[3] s32, v_speed: float = 1.0, v_min: s32 = 0, v_max: s32 = 0, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui "?DragInt3@ImGui@@YA_NPEBDQEAHMHH0H@Z";
    DragInt4 :: (label: *u8, v: *[4] s32, v_speed: float = 1.0, v_min: s32 = 0, v_max: s32 = 0, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui "?DragInt4@ImGui@@YA_NPEBDQEAHMHH0H@Z";
    DragIntRange2 :: (label: *u8, v_current_min: *s32, v_current_max: *s32, v_speed: float = 1.0, v_min: s32 = 0, v_max: s32 = 0, format: *u8 = "%d", format_max: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui "?DragIntRange2@ImGui@@YA_NPEBDPEAH1MHH00H@Z";
    DragScalar :: (label: *u8, data_type: DataType, p_data: *void, v_speed: float = 1.0, p_min: *void = null, p_max: *void = null, format: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui "?DragScalar@ImGui@@YA_NPEBDHPEAXMPEBX20H@Z";
    DragScalarN :: (label: *u8, data_type: DataType, p_data: *void, components: s32, v_speed: float = 1.0, p_min: *void = null, p_max: *void = null, format: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui "?DragScalarN@ImGui@@YA_NPEBDHPEAXHMPEBX20H@Z";
    SliderFloat :: (label: *u8, v: *float, v_min: float, v_max: float, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui "?SliderFloat@ImGui@@YA_NPEBDPEAMMM0H@Z";
    SliderFloat2 :: (label: *u8, v: *[2] float, v_min: float, v_max: float, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui "?SliderFloat2@ImGui@@YA_NPEBDQEAMMM0H@Z";
    SliderFloat3 :: (label: *u8, v: *[3] float, v_min: float, v_max: float, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui "?SliderFloat3@ImGui@@YA_NPEBDQEAMMM0H@Z";
    SliderFloat4 :: (label: *u8, v: *[4] float, v_min: float, v_max: float, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool #foreign imgui "?SliderFloat4@ImGui@@YA_NPEBDQEAMMM0H@Z";
    SliderAngle :: (label: *u8, v_rad: *float, v_degrees_min: float = -360.0, v_degrees_max: float = 360.0, format: *u8 = "%.0f deg", flags: SliderFlags = .None) -> bool #foreign imgui "?SliderAngle@ImGui@@YA_NPEBDPEAMMM0H@Z";
    SliderInt :: (label: *u8, v: *s32, v_min: s32, v_max: s32, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui "?SliderInt@ImGui@@YA_NPEBDPEAHHH0H@Z";
    SliderInt2 :: (label: *u8, v: *[2] s32, v_min: s32, v_max: s32, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui "?SliderInt2@ImGui@@YA_NPEBDQEAHHH0H@Z";
    SliderInt3 :: (label: *u8, v: *[3] s32, v_min: s32, v_max: s32, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui "?SliderInt3@ImGui@@YA_NPEBDQEAHHH0H@Z";
    SliderInt4 :: (label: *u8, v: *[4] s32, v_min: s32, v_max: s32, format: *u8 = "%d", flags: SliderFlags = .None) -> bool #foreign imgui "?SliderInt4@ImGui@@YA_NPEBDQEAHHH0H@Z";
    SliderScalar :: (label: *u8, data_type: DataType, p_data: *void, p_min: *void, p_max: *void, format: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui "?SliderScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z";
    SliderScalarN :: (label: *u8, data_type: DataType, p_data: *void, components: s32, p_min: *void, p_max: *void, format: *u8 = null, flags: SliderFlags = .None) -> bool #foreign imgui "?SliderScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z";
    VSliderFloat :: (label: *u8, size: ImVec2, v: *float, v_min: float, v_max: float, format: *u8 = "%.3f", flags: SliderFlags = .None) -> bool {
        VSliderFloat_internal :: (label: *u8, size: *ImVec2, v: *float, v_min: float, v_max: float, format: *u8, flags: SliderFlags) -> bool #foreign imgui "?VSliderFloat@ImGui@@YA_NPEBDAEBUImVec2@@PEAMMM0H@Z";
        return VSliderFloat_internal(label, *size, v, v_min, v_max, format, flags);
    }
    VSliderInt :: (label: *u8, size: ImVec2, v: *s32, v_min: s32, v_max: s32, format: *u8 = "%d", flags: SliderFlags = .None) -> bool {
        VSliderInt_internal :: (label: *u8, size: *ImVec2, v: *s32, v_min: s32, v_max: s32, format: *u8, flags: SliderFlags) -> bool #foreign imgui "?VSliderInt@ImGui@@YA_NPEBDAEBUImVec2@@PEAHHH0H@Z";
        return VSliderInt_internal(label, *size, v, v_min, v_max, format, flags);
    }
    VSliderScalar :: (label: *u8, size: ImVec2, data_type: DataType, p_data: *void, p_min: *void, p_max: *void, format: *u8 = null, flags: SliderFlags = .None) -> bool {
        VSliderScalar_internal :: (label: *u8, size: *ImVec2, data_type: DataType, p_data: *void, p_min: *void, p_max: *void, format: *u8, flags: SliderFlags) -> bool #foreign imgui "?VSliderScalar@ImGui@@YA_NPEBDAEBUImVec2@@HPEAXPEBX30H@Z";
        return VSliderScalar_internal(label, *size, data_type, p_data, p_min, p_max, format, flags);
    }
    InputText :: (label: *u8, buf: *u8, buf_size: size_t, flags: InputTextFlags = .None, callback: InputTextCallback = null, user_data: *void = null) -> bool #foreign imgui "?InputText@ImGui@@YA_NPEBDPEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z";
    InputTextMultiline :: (label: *u8, buf: *u8, buf_size: size_t, size: ImVec2 = ImVec2.{0,0}, flags: InputTextFlags = .None, callback: InputTextCallback = null, user_data: *void = null) -> bool {
        InputTextMultiline_internal :: (label: *u8, buf: *u8, buf_size: size_t, size: *ImVec2, flags: InputTextFlags, callback: InputTextCallback, user_data: *void) -> bool #foreign imgui "?InputTextMultiline@ImGui@@YA_NPEBDPEAD_KAEBUImVec2@@HP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z";
        return InputTextMultiline_internal(label, buf, buf_size, *size, flags, callback, user_data);
    }
    InputTextWithHint :: (label: *u8, hint: *u8, buf: *u8, buf_size: size_t, flags: InputTextFlags = .None, callback: InputTextCallback = null, user_data: *void = null) -> bool #foreign imgui "?InputTextWithHint@ImGui@@YA_NPEBD0PEAD_KHP6AHPEAUImGuiInputTextCallbackData@@@ZPEAX@Z";
    InputFloat :: (label: *u8, v: *float, step: float = 0.0, step_fast: float = 0.0, format: *u8 = "%.3f", flags: InputTextFlags = .None) -> bool #foreign imgui "?InputFloat@ImGui@@YA_NPEBDPEAMMM0H@Z";
    InputFloat2 :: (label: *u8, v: *[2] float, format: *u8 = "%.3f", flags: InputTextFlags = .None) -> bool #foreign imgui "?InputFloat2@ImGui@@YA_NPEBDQEAM0H@Z";
    InputFloat3 :: (label: *u8, v: *[3] float, format: *u8 = "%.3f", flags: InputTextFlags = .None) -> bool #foreign imgui "?InputFloat3@ImGui@@YA_NPEBDQEAM0H@Z";
    InputFloat4 :: (label: *u8, v: *[4] float, format: *u8 = "%.3f", flags: InputTextFlags = .None) -> bool #foreign imgui "?InputFloat4@ImGui@@YA_NPEBDQEAM0H@Z";
    InputInt :: (label: *u8, v: *s32, step: s32 = 1, step_fast: s32 = 100, flags: InputTextFlags = .None) -> bool #foreign imgui "?InputInt@ImGui@@YA_NPEBDPEAHHHH@Z";
    InputInt2 :: (label: *u8, v: *[2] s32, flags: InputTextFlags = .None) -> bool #foreign imgui "?InputInt2@ImGui@@YA_NPEBDQEAHH@Z";
    InputInt3 :: (label: *u8, v: *[3] s32, flags: InputTextFlags = .None) -> bool #foreign imgui "?InputInt3@ImGui@@YA_NPEBDQEAHH@Z";
    InputInt4 :: (label: *u8, v: *[4] s32, flags: InputTextFlags = .None) -> bool #foreign imgui "?InputInt4@ImGui@@YA_NPEBDQEAHH@Z";
    InputDouble :: (label: *u8, v: *float64, step: float64 = 0.0, step_fast: float64 = 0.0, format: *u8 = "%.6f", flags: InputTextFlags = .None) -> bool #foreign imgui "?InputDouble@ImGui@@YA_NPEBDPEANNN0H@Z";
    InputScalar :: (label: *u8, data_type: DataType, p_data: *void, p_step: *void = null, p_step_fast: *void = null, format: *u8 = null, flags: InputTextFlags = .None) -> bool #foreign imgui "?InputScalar@ImGui@@YA_NPEBDHPEAXPEBX20H@Z";
    InputScalarN :: (label: *u8, data_type: DataType, p_data: *void, components: s32, p_step: *void = null, p_step_fast: *void = null, format: *u8 = null, flags: InputTextFlags = .None) -> bool #foreign imgui "?InputScalarN@ImGui@@YA_NPEBDHPEAXHPEBX20H@Z";
    ColorEdit3 :: (label: *u8, col: *[3] float, flags: ColorEditFlags = .None) -> bool #foreign imgui "?ColorEdit3@ImGui@@YA_NPEBDQEAMH@Z";
    ColorEdit4 :: (label: *u8, col: *[4] float, flags: ColorEditFlags = .None) -> bool #foreign imgui "?ColorEdit4@ImGui@@YA_NPEBDQEAMH@Z";
    ColorPicker3 :: (label: *u8, col: *[3] float, flags: ColorEditFlags = .None) -> bool #foreign imgui "?ColorPicker3@ImGui@@YA_NPEBDQEAMH@Z";
    ColorPicker4 :: (label: *u8, col: *[4] float, flags: ColorEditFlags = .None, ref_col: *float = null) -> bool #foreign imgui "?ColorPicker4@ImGui@@YA_NPEBDQEAMHPEBM@Z";
    ColorButton :: (desc_id: *u8, col: ImVec4, flags: ColorEditFlags = .None, size: ImVec2 = ImVec2.{0,0}) -> bool {
        ColorButton_internal :: (desc_id: *u8, col: *ImVec4, flags: ColorEditFlags, size: ImVec2) -> bool #foreign imgui "?ColorButton@ImGui@@YA_NPEBDAEBUImVec4@@HUImVec2@@@Z";
        return ColorButton_internal(desc_id, *col, flags, size);
    }
    SetColorEditOptions :: (flags: ColorEditFlags) -> void #foreign imgui "?SetColorEditOptions@ImGui@@YAXH@Z";
    TreeNode :: (label: *u8) -> bool #foreign imgui "?TreeNode@ImGui@@YA_NPEBD@Z";
    TreeNode :: (str_id: *u8, fmt: *u8, __args: ..Any) -> bool #foreign imgui "?TreeNode@ImGui@@YA_NPEBD0ZZ";
    TreeNode :: (ptr_id: *void, fmt: *u8, __args: ..Any) -> bool #foreign imgui "?TreeNode@ImGui@@YA_NPEBXPEBDZZ";
    /* (jaicc: omitted function with valist)
    TreeNodeV :: (str_id: *u8, fmt: *u8, args: va_list) -> bool #foreign imgui "?TreeNodeV@ImGui@@YA_NPEBD0PEAD@Z";
    */

    /* (jaicc: omitted function with valist)
    TreeNodeV :: (ptr_id: *void, fmt: *u8, args: va_list) -> bool #foreign imgui "?TreeNodeV@ImGui@@YA_NPEBXPEBDPEAD@Z";
    */

    TreeNodeEx :: (label: *u8, flags: TreeNodeFlags = .None) -> bool #foreign imgui "?TreeNodeEx@ImGui@@YA_NPEBDH@Z";
    TreeNodeEx :: (str_id: *u8, flags: TreeNodeFlags, fmt: *u8, __args: ..Any) -> bool #foreign imgui "?TreeNodeEx@ImGui@@YA_NPEBDH0ZZ";
    TreeNodeEx :: (ptr_id: *void, flags: TreeNodeFlags, fmt: *u8, __args: ..Any) -> bool #foreign imgui "?TreeNodeEx@ImGui@@YA_NPEBXHPEBDZZ";
    /* (jaicc: omitted function with valist)
    TreeNodeExV :: (str_id: *u8, flags: TreeNodeFlags, fmt: *u8, args: va_list) -> bool #foreign imgui "?TreeNodeExV@ImGui@@YA_NPEBDH0PEAD@Z";
    */

    /* (jaicc: omitted function with valist)
    TreeNodeExV :: (ptr_id: *void, flags: TreeNodeFlags, fmt: *u8, args: va_list) -> bool #foreign imgui "?TreeNodeExV@ImGui@@YA_NPEBXHPEBDPEAD@Z";
    */

    TreePush :: (str_id: *u8) -> void #foreign imgui "?TreePush@ImGui@@YAXPEBD@Z";
    TreePush :: (ptr_id: *void = null) -> void #foreign imgui "?TreePush@ImGui@@YAXPEBX@Z";
    TreePop :: () -> void #foreign imgui "?TreePop@ImGui@@YAXXZ";
    GetTreeNodeToLabelSpacing :: () -> float #foreign imgui "?GetTreeNodeToLabelSpacing@ImGui@@YAMXZ";
    CollapsingHeader :: (label: *u8, flags: TreeNodeFlags = .None) -> bool #foreign imgui "?CollapsingHeader@ImGui@@YA_NPEBDH@Z";
    CollapsingHeader :: (label: *u8, p_visible: *bool, flags: TreeNodeFlags = .None) -> bool #foreign imgui "?CollapsingHeader@ImGui@@YA_NPEBDPEA_NH@Z";
    SetNextItemOpen :: (is_open: bool, cond: Cond = .None) -> void #foreign imgui "?SetNextItemOpen@ImGui@@YAX_NH@Z";
    Selectable :: (label: *u8, selected: bool = false, flags: SelectableFlags = .None, size: ImVec2 = ImVec2.{0,0}) -> bool {
        Selectable_internal :: (label: *u8, selected: bool, flags: SelectableFlags, size: *ImVec2) -> bool #foreign imgui "?Selectable@ImGui@@YA_NPEBD_NHAEBUImVec2@@@Z";
        return Selectable_internal(label, selected, flags, *size);
    }
    Selectable :: (label: *u8, p_selected: *bool, flags: SelectableFlags = .None, size: ImVec2 = ImVec2.{0,0}) -> bool {
        Selectable_internal :: (label: *u8, p_selected: *bool, flags: SelectableFlags, size: *ImVec2) -> bool #foreign imgui "?Selectable@ImGui@@YA_NPEBDPEA_NHAEBUImVec2@@@Z";
        return Selectable_internal(label, p_selected, flags, *size);
    }
    BeginListBox :: (label: *u8, size: ImVec2 = ImVec2.{0,0}) -> bool {
        BeginListBox_internal :: (label: *u8, size: *ImVec2) -> bool #foreign imgui "?BeginListBox@ImGui@@YA_NPEBDAEBUImVec2@@@Z";
        return BeginListBox_internal(label, *size);
    }
    EndListBox :: () -> void #foreign imgui "?EndListBox@ImGui@@YAXXZ";
    ListBox :: (label: *u8, current_item: *s32, items: **u8, items_count: s32, height_in_items: s32 = -1) -> bool #foreign imgui "?ListBox@ImGui@@YA_NPEBDPEAHQEBQEBDHH@Z";
    ListBox :: (label: *u8, current_item: *s32, items_getter: #type (a0: *void, a1: s32, a2: **u8) -> bool #c_call, data: *void, items_count: s32, height_in_items: s32 = -1) -> bool #foreign imgui "?ListBox@ImGui@@YA_NPEBDPEAHP6A_NPEAXHPEAPEBD@Z2HH@Z";
    PlotLines :: (label: *u8, values: *float, values_count: s32, values_offset: s32 = 0, overlay_text: *u8 = null, scale_min: float = 340282346638528859000000000000000000000.0, scale_max: float = 340282346638528859000000000000000000000.0, graph_size: ImVec2 = ImVec2.{0,0}, stride: s32 = 4) -> void #foreign imgui "?PlotLines@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z";
    PlotLines :: (label: *u8, values_getter: #type (a0: *void, a1: s32) -> float #c_call, data: *void, values_count: s32, values_offset: s32 = 0, overlay_text: *u8 = null, scale_min: float = 340282346638528859000000000000000000000.0, scale_max: float = 340282346638528859000000000000000000000.0, graph_size: ImVec2 = ImVec2.{0,0}) -> void #foreign imgui "?PlotLines@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z";
    PlotHistogram :: (label: *u8, values: *float, values_count: s32, values_offset: s32 = 0, overlay_text: *u8 = null, scale_min: float = 340282346638528859000000000000000000000.0, scale_max: float = 340282346638528859000000000000000000000.0, graph_size: ImVec2 = ImVec2.{0,0}, stride: s32 = 4) -> void #foreign imgui "?PlotHistogram@ImGui@@YAXPEBDPEBMHH0MMUImVec2@@H@Z";
    PlotHistogram :: (label: *u8, values_getter: #type (a0: *void, a1: s32) -> float #c_call, data: *void, values_count: s32, values_offset: s32 = 0, overlay_text: *u8 = null, scale_min: float = 340282346638528859000000000000000000000.0, scale_max: float = 340282346638528859000000000000000000000.0, graph_size: ImVec2 = ImVec2.{0,0}) -> void #foreign imgui "?PlotHistogram@ImGui@@YAXPEBDP6AMPEAXH@Z1HH0MMUImVec2@@@Z";
    Value :: (prefix: *u8, b: bool) -> void #foreign imgui "?Value@ImGui@@YAXPEBD_N@Z";
    Value :: (prefix: *u8, v: s32) -> void #foreign imgui "?Value@ImGui@@YAXPEBDH@Z";
    Value :: (prefix: *u8, v: u32) -> void #foreign imgui "?Value@ImGui@@YAXPEBDI@Z";
    Value :: (prefix: *u8, v: float, float_format: *u8 = null) -> void #foreign imgui "?Value@ImGui@@YAXPEBDM0@Z";
    BeginMenuBar :: () -> bool #foreign imgui "?BeginMenuBar@ImGui@@YA_NXZ";
    EndMenuBar :: () -> void #foreign imgui "?EndMenuBar@ImGui@@YAXXZ";
    BeginMainMenuBar :: () -> bool #foreign imgui "?BeginMainMenuBar@ImGui@@YA_NXZ";
    EndMainMenuBar :: () -> void #foreign imgui "?EndMainMenuBar@ImGui@@YAXXZ";
    BeginMenu :: (label: *u8, enabled: bool = true) -> bool #foreign imgui "?BeginMenu@ImGui@@YA_NPEBD_N@Z";
    EndMenu :: () -> void #foreign imgui "?EndMenu@ImGui@@YAXXZ";
    MenuItem :: (label: *u8, shortcut: *u8 = null, selected: bool = false, enabled: bool = true) -> bool #foreign imgui "?MenuItem@ImGui@@YA_NPEBD0_N1@Z";
    MenuItem :: (label: *u8, shortcut: *u8, p_selected: *bool, enabled: bool = true) -> bool #foreign imgui "?MenuItem@ImGui@@YA_NPEBD0PEA_N_N@Z";
    BeginTooltip :: () -> void #foreign imgui "?BeginTooltip@ImGui@@YAXXZ";
    EndTooltip :: () -> void #foreign imgui "?EndTooltip@ImGui@@YAXXZ";
    SetTooltip :: (fmt: *u8, __args: ..Any) -> void #foreign imgui "?SetTooltip@ImGui@@YAXPEBDZZ";
    /* (jaicc: omitted function with valist)
    SetTooltipV :: (fmt: *u8, args: va_list) -> void #foreign imgui "?SetTooltipV@ImGui@@YAXPEBDPEAD@Z";
    */

    BeginPopup :: (str_id: *u8, flags: WindowFlags = .None) -> bool #foreign imgui "?BeginPopup@ImGui@@YA_NPEBDH@Z";
    BeginPopupModal :: (name: *u8, p_open: *bool = null, flags: WindowFlags = .None) -> bool #foreign imgui "?BeginPopupModal@ImGui@@YA_NPEBDPEA_NH@Z";
    EndPopup :: () -> void #foreign imgui "?EndPopup@ImGui@@YAXXZ";
    OpenPopup :: (str_id: *u8, popup_flags: PopupFlags = .None) -> void #foreign imgui "?OpenPopup@ImGui@@YAXPEBDH@Z";
    OpenPopup :: (id: ID, popup_flags: PopupFlags = .None) -> void #foreign imgui "?OpenPopup@ImGui@@YAXIH@Z";
    OpenPopupOnItemClick :: (str_id: *u8 = null, popup_flags: PopupFlags = .MouseButtonRight) -> void #foreign imgui "?OpenPopupOnItemClick@ImGui@@YAXPEBDH@Z";
    CloseCurrentPopup :: () -> void #foreign imgui "?CloseCurrentPopup@ImGui@@YAXXZ";
    BeginPopupContextItem :: (str_id: *u8 = null, popup_flags: PopupFlags = .MouseButtonRight) -> bool #foreign imgui "?BeginPopupContextItem@ImGui@@YA_NPEBDH@Z";
    BeginPopupContextWindow :: (str_id: *u8 = null, popup_flags: PopupFlags = .MouseButtonRight) -> bool #foreign imgui "?BeginPopupContextWindow@ImGui@@YA_NPEBDH@Z";
    BeginPopupContextVoid :: (str_id: *u8 = null, popup_flags: PopupFlags = .MouseButtonRight) -> bool #foreign imgui "?BeginPopupContextVoid@ImGui@@YA_NPEBDH@Z";
    IsPopupOpen :: (str_id: *u8, flags: PopupFlags = .None) -> bool #foreign imgui "?IsPopupOpen@ImGui@@YA_NPEBDH@Z";
    BeginTable :: (str_id: *u8, column: s32, flags: TableFlags = .None, outer_size: ImVec2 = ImVec2.{0.0 ,0.0 }, inner_width: float = 0.0) -> bool {
        BeginTable_internal :: (str_id: *u8, column: s32, flags: TableFlags, outer_size: *ImVec2, inner_width: float) -> bool #foreign imgui "?BeginTable@ImGui@@YA_NPEBDHHAEBUImVec2@@M@Z";
        return BeginTable_internal(str_id, column, flags, *outer_size, inner_width);
    }
    EndTable :: () -> void #foreign imgui "?EndTable@ImGui@@YAXXZ";
    TableNextRow :: (row_flags: TableRowFlags = .None, min_row_height: float = 0.0) -> void #foreign imgui "?TableNextRow@ImGui@@YAXHM@Z";
    TableNextColumn :: () -> bool #foreign imgui "?TableNextColumn@ImGui@@YA_NXZ";
    TableSetColumnIndex :: (column_n: s32) -> bool #foreign imgui "?TableSetColumnIndex@ImGui@@YA_NH@Z";
    TableSetupColumn :: (label: *u8, flags: TableColumnFlags = .None, init_width_or_weight: float = 0.0, user_id: ID) -> void #foreign imgui "?TableSetupColumn@ImGui@@YAXPEBDHMI@Z";
    TableSetupScrollFreeze :: (cols: s32, rows: s32) -> void #foreign imgui "?TableSetupScrollFreeze@ImGui@@YAXHH@Z";
    TableHeadersRow :: () -> void #foreign imgui "?TableHeadersRow@ImGui@@YAXXZ";
    TableHeader :: (label: *u8) -> void #foreign imgui "?TableHeader@ImGui@@YAXPEBD@Z";
    TableGetSortSpecs :: () -> *TableSortSpecs #foreign imgui "?TableGetSortSpecs@ImGui@@YAPEAUImGuiTableSortSpecs@@XZ";
    TableGetColumnCount :: () -> s32 #foreign imgui "?TableGetColumnCount@ImGui@@YAHXZ";
    TableGetColumnIndex :: () -> s32 #foreign imgui "?TableGetColumnIndex@ImGui@@YAHXZ";
    TableGetRowIndex :: () -> s32 #foreign imgui "?TableGetRowIndex@ImGui@@YAHXZ";
    TableGetColumnName :: (column_n: s32 = -1) -> *u8 #foreign imgui "?TableGetColumnName@ImGui@@YAPEBDH@Z";
    TableGetColumnFlags :: (column_n: s32 = -1) -> TableColumnFlags #foreign imgui "?TableGetColumnFlags@ImGui@@YAHH@Z";
    TableSetColumnEnabled :: (column_n: s32, v: bool) -> void #foreign imgui "?TableSetColumnEnabled@ImGui@@YAXH_N@Z";
    TableSetBgColor :: (target: TableBgTarget, color: ImU32, column_n: s32 = -1) -> void #foreign imgui "?TableSetBgColor@ImGui@@YAXHIH@Z";
    Columns :: (count: s32 = 1, id: *u8 = null, border: bool = true) -> void #foreign imgui "?Columns@ImGui@@YAXHPEBD_N@Z";
    NextColumn :: () -> void #foreign imgui "?NextColumn@ImGui@@YAXXZ";
    GetColumnIndex :: () -> s32 #foreign imgui "?GetColumnIndex@ImGui@@YAHXZ";
    GetColumnWidth :: (column_index: s32 = -1) -> float #foreign imgui "?GetColumnWidth@ImGui@@YAMH@Z";
    SetColumnWidth :: (column_index: s32, width: float) -> void #foreign imgui "?SetColumnWidth@ImGui@@YAXHM@Z";
    GetColumnOffset :: (column_index: s32 = -1) -> float #foreign imgui "?GetColumnOffset@ImGui@@YAMH@Z";
    SetColumnOffset :: (column_index: s32, offset_x: float) -> void #foreign imgui "?SetColumnOffset@ImGui@@YAXHM@Z";
    GetColumnsCount :: () -> s32 #foreign imgui "?GetColumnsCount@ImGui@@YAHXZ";
    BeginTabBar :: (str_id: *u8, flags: TabBarFlags = .None) -> bool #foreign imgui "?BeginTabBar@ImGui@@YA_NPEBDH@Z";
    EndTabBar :: () -> void #foreign imgui "?EndTabBar@ImGui@@YAXXZ";
    BeginTabItem :: (label: *u8, p_open: *bool = null, flags: TabItemFlags = .None) -> bool #foreign imgui "?BeginTabItem@ImGui@@YA_NPEBDPEA_NH@Z";
    EndTabItem :: () -> void #foreign imgui "?EndTabItem@ImGui@@YAXXZ";
    TabItemButton :: (label: *u8, flags: TabItemFlags = .None) -> bool #foreign imgui "?TabItemButton@ImGui@@YA_NPEBDH@Z";
    SetTabItemClosed :: (tab_or_docked_window_label: *u8) -> void #foreign imgui "?SetTabItemClosed@ImGui@@YAXPEBD@Z";
    DockSpace :: (id: ID, size: ImVec2 = ImVec2.{0,0}, flags: DockNodeFlags = .None, window_class: *WindowClass = null) -> ID {
        DockSpace_internal :: (id: ID, size: *ImVec2, flags: DockNodeFlags, window_class: *WindowClass) -> ID #foreign imgui "?DockSpace@ImGui@@YAIIAEBUImVec2@@HPEBUImGuiWindowClass@@@Z";
        return DockSpace_internal(id, *size, flags, window_class);
    }
    DockSpaceOverViewport :: (viewport: *Viewport = null, flags: DockNodeFlags = .None, window_class: *WindowClass = null) -> ID #foreign imgui "?DockSpaceOverViewport@ImGui@@YAIPEBUImGuiViewport@@HPEBUImGuiWindowClass@@@Z";
    SetNextWindowDockID :: (dock_id: ID, cond: Cond = .None) -> void #foreign imgui "?SetNextWindowDockID@ImGui@@YAXIH@Z";
    SetNextWindowClass :: (window_class: *WindowClass) -> void #foreign imgui "?SetNextWindowClass@ImGui@@YAXPEBUImGuiWindowClass@@@Z";
    GetWindowDockID :: () -> ID #foreign imgui "?GetWindowDockID@ImGui@@YAIXZ";
    IsWindowDocked :: () -> bool #foreign imgui "?IsWindowDocked@ImGui@@YA_NXZ";
    LogToTTY :: (auto_open_depth: s32 = -1) -> void #foreign imgui "?LogToTTY@ImGui@@YAXH@Z";
    LogToFile :: (auto_open_depth: s32 = -1, filename: *u8 = null) -> void #foreign imgui "?LogToFile@ImGui@@YAXHPEBD@Z";
    LogToClipboard :: (auto_open_depth: s32 = -1) -> void #foreign imgui "?LogToClipboard@ImGui@@YAXH@Z";
    LogFinish :: () -> void #foreign imgui "?LogFinish@ImGui@@YAXXZ";
    LogButtons :: () -> void #foreign imgui "?LogButtons@ImGui@@YAXXZ";
    LogText :: (fmt: *u8, __args: ..Any) -> void #foreign imgui "?LogText@ImGui@@YAXPEBDZZ";
    /* (jaicc: omitted function with valist)
    LogTextV :: (fmt: *u8, args: va_list) -> void #foreign imgui "?LogTextV@ImGui@@YAXPEBDPEAD@Z";
    */

    BeginDragDropSource :: (flags: DragDropFlags = .None) -> bool #foreign imgui "?BeginDragDropSource@ImGui@@YA_NH@Z";
    SetDragDropPayload :: (type: *u8, data: *void, sz: size_t, cond: Cond = .None) -> bool #foreign imgui "?SetDragDropPayload@ImGui@@YA_NPEBDPEBX_KH@Z";
    EndDragDropSource :: () -> void #foreign imgui "?EndDragDropSource@ImGui@@YAXXZ";
    BeginDragDropTarget :: () -> bool #foreign imgui "?BeginDragDropTarget@ImGui@@YA_NXZ";
    AcceptDragDropPayload :: (type: *u8, flags: DragDropFlags = .None) -> *Payload #foreign imgui "?AcceptDragDropPayload@ImGui@@YAPEBUImGuiPayload@@PEBDH@Z";
    EndDragDropTarget :: () -> void #foreign imgui "?EndDragDropTarget@ImGui@@YAXXZ";
    GetDragDropPayload :: () -> *Payload #foreign imgui "?GetDragDropPayload@ImGui@@YAPEBUImGuiPayload@@XZ";
    PushClipRect :: (clip_rect_min: ImVec2, clip_rect_max: ImVec2, intersect_with_current_clip_rect: bool) {
        PushClipRect_internal :: (clip_rect_min: *ImVec2, clip_rect_max: *ImVec2, intersect_with_current_clip_rect: bool) -> void #foreign imgui "?PushClipRect@ImGui@@YAXAEBUImVec2@@0_N@Z";
        PushClipRect_internal(*clip_rect_min, *clip_rect_max, intersect_with_current_clip_rect);
    }
    PopClipRect :: () -> void #foreign imgui "?PopClipRect@ImGui@@YAXXZ";
    SetItemDefaultFocus :: () -> void #foreign imgui "?SetItemDefaultFocus@ImGui@@YAXXZ";
    SetKeyboardFocusHere :: (offset: s32 = 0) -> void #foreign imgui "?SetKeyboardFocusHere@ImGui@@YAXH@Z";
    IsItemHovered :: (flags: HoveredFlags = .None) -> bool #foreign imgui "?IsItemHovered@ImGui@@YA_NH@Z";
    IsItemActive :: () -> bool #foreign imgui "?IsItemActive@ImGui@@YA_NXZ";
    IsItemFocused :: () -> bool #foreign imgui "?IsItemFocused@ImGui@@YA_NXZ";
    IsItemClicked :: (mouse_button: MouseButton = .Left) -> bool #foreign imgui "?IsItemClicked@ImGui@@YA_NH@Z";
    IsItemVisible :: () -> bool #foreign imgui "?IsItemVisible@ImGui@@YA_NXZ";
    IsItemEdited :: () -> bool #foreign imgui "?IsItemEdited@ImGui@@YA_NXZ";
    IsItemActivated :: () -> bool #foreign imgui "?IsItemActivated@ImGui@@YA_NXZ";
    IsItemDeactivated :: () -> bool #foreign imgui "?IsItemDeactivated@ImGui@@YA_NXZ";
    IsItemDeactivatedAfterEdit :: () -> bool #foreign imgui "?IsItemDeactivatedAfterEdit@ImGui@@YA_NXZ";
    IsItemToggledOpen :: () -> bool #foreign imgui "?IsItemToggledOpen@ImGui@@YA_NXZ";
    IsAnyItemHovered :: () -> bool #foreign imgui "?IsAnyItemHovered@ImGui@@YA_NXZ";
    IsAnyItemActive :: () -> bool #foreign imgui "?IsAnyItemActive@ImGui@@YA_NXZ";
    IsAnyItemFocused :: () -> bool #foreign imgui "?IsAnyItemFocused@ImGui@@YA_NXZ";
    GetItemRectMin :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetItemRectMin@ImGui@@YA?AUImVec2@@XZ";
    GetItemRectMax :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetItemRectMax@ImGui@@YA?AUImVec2@@XZ";
    GetItemRectSize :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetItemRectSize@ImGui@@YA?AUImVec2@@XZ";
    SetItemAllowOverlap :: () -> void #foreign imgui "?SetItemAllowOverlap@ImGui@@YAXXZ";
    GetMainViewport :: () -> *Viewport #foreign imgui "?GetMainViewport@ImGui@@YAPEAUImGuiViewport@@XZ";
    IsRectVisible :: (size: ImVec2) -> bool {
        IsRectVisible_internal :: (size: *ImVec2) -> bool #foreign imgui "?IsRectVisible@ImGui@@YA_NAEBUImVec2@@@Z";
        return IsRectVisible_internal(*size);
    }
    IsRectVisible :: (rect_min: ImVec2, rect_max: ImVec2) -> bool {
        IsRectVisible_internal :: (rect_min: *ImVec2, rect_max: *ImVec2) -> bool #foreign imgui "?IsRectVisible@ImGui@@YA_NAEBUImVec2@@0@Z";
        return IsRectVisible_internal(*rect_min, *rect_max);
    }
    GetTime :: () -> float64 #foreign imgui "?GetTime@ImGui@@YANXZ";
    GetFrameCount :: () -> s32 #foreign imgui "?GetFrameCount@ImGui@@YAHXZ";
    GetBackgroundDrawList :: () -> *ImDrawList #foreign imgui "?GetBackgroundDrawList@ImGui@@YAPEAUImDrawList@@XZ";
    GetForegroundDrawList :: () -> *ImDrawList #foreign imgui "?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@XZ";
    GetBackgroundDrawList :: (viewport: *Viewport) -> *ImDrawList #foreign imgui "?GetBackgroundDrawList@ImGui@@YAPEAUImDrawList@@PEAUImGuiViewport@@@Z";
    GetForegroundDrawList :: (viewport: *Viewport) -> *ImDrawList #foreign imgui "?GetForegroundDrawList@ImGui@@YAPEAUImDrawList@@PEAUImGuiViewport@@@Z";
    GetDrawListSharedData :: () -> *ImDrawListSharedData #foreign imgui "?GetDrawListSharedData@ImGui@@YAPEAUImDrawListSharedData@@XZ";
    GetStyleColorName :: (idx: Col) -> *u8 #foreign imgui "?GetStyleColorName@ImGui@@YAPEBDH@Z";
    SetStateStorage :: (storage: *Storage) -> void #foreign imgui "?SetStateStorage@ImGui@@YAXPEAUImGuiStorage@@@Z";
    GetStateStorage :: () -> *Storage #foreign imgui "?GetStateStorage@ImGui@@YAPEAUImGuiStorage@@XZ";
    CalcListClipping :: (items_count: s32, items_height: float, out_items_display_start: *s32, out_items_display_end: *s32) -> void #foreign imgui "?CalcListClipping@ImGui@@YAXHMPEAH0@Z";
    BeginChildFrame :: (id: ID, size: ImVec2, flags: WindowFlags = .None) -> bool {
        BeginChildFrame_internal :: (id: ID, size: *ImVec2, flags: WindowFlags) -> bool #foreign imgui "?BeginChildFrame@ImGui@@YA_NIAEBUImVec2@@H@Z";
        return BeginChildFrame_internal(id, *size, flags);
    }
    EndChildFrame :: () -> void #foreign imgui "?EndChildFrame@ImGui@@YAXXZ";
    CalcTextSize :: (text: string, hide_text_after_double_hash: bool = false, wrap_width: float = -1.0) -> ImVec2 {
        CalcTextSize_internal :: (text: *u8, text_end: *u8, hide_text_after_double_hash: bool, wrap_width: float) -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?CalcTextSize@ImGui@@YA?AUImVec2@@PEBD0_NM@Z";
        return CalcTextSize_internal(text.data, text.data + text.count, hide_text_after_double_hash, wrap_width);
    }
    ColorConvertU32ToFloat4 :: (in: ImU32) -> ImVec4 #cpp_return_type_is_non_pod #foreign imgui "?ColorConvertU32ToFloat4@ImGui@@YA?AUImVec4@@I@Z";
    ColorConvertFloat4ToU32 :: (in: ImVec4) -> ImU32 {
        ColorConvertFloat4ToU32_internal :: (in: *ImVec4) -> ImU32 #foreign imgui "?ColorConvertFloat4ToU32@ImGui@@YAIAEBUImVec4@@@Z";
        return ColorConvertFloat4ToU32_internal(*in);
    }
    ColorConvertRGBtoHSV :: (r: float, g: float, b: float, out_h: *float, out_s: *float, out_v: *float) -> void #foreign imgui "?ColorConvertRGBtoHSV@ImGui@@YAXMMMAEAM00@Z";
    ColorConvertHSVtoRGB :: (h: float, s: float, v: float, out_r: *float, out_g: *float, out_b: *float) -> void #foreign imgui "?ColorConvertHSVtoRGB@ImGui@@YAXMMMAEAM00@Z";
    GetKeyIndex :: (imgui_key: Key) -> s32 #foreign imgui "?GetKeyIndex@ImGui@@YAHH@Z";
    IsKeyDown :: (user_key_index: s32) -> bool #foreign imgui "?IsKeyDown@ImGui@@YA_NH@Z";
    IsKeyPressed :: (user_key_index: s32, repeat: bool = true) -> bool #foreign imgui "?IsKeyPressed@ImGui@@YA_NH_N@Z";
    IsKeyReleased :: (user_key_index: s32) -> bool #foreign imgui "?IsKeyReleased@ImGui@@YA_NH@Z";
    GetKeyPressedAmount :: (key_index: s32, repeat_delay: float, rate: float) -> s32 #foreign imgui "?GetKeyPressedAmount@ImGui@@YAHHMM@Z";
    CaptureKeyboardFromApp :: (want_capture_keyboard_value: bool = true) -> void #foreign imgui "?CaptureKeyboardFromApp@ImGui@@YAX_N@Z";
    IsMouseDown :: (button: MouseButton) -> bool #foreign imgui "?IsMouseDown@ImGui@@YA_NH@Z";
    IsMouseClicked :: (button: MouseButton, repeat: bool = false) -> bool #foreign imgui "?IsMouseClicked@ImGui@@YA_NH_N@Z";
    IsMouseReleased :: (button: MouseButton) -> bool #foreign imgui "?IsMouseReleased@ImGui@@YA_NH@Z";
    IsMouseDoubleClicked :: (button: MouseButton) -> bool #foreign imgui "?IsMouseDoubleClicked@ImGui@@YA_NH@Z";
    IsMouseHoveringRect :: (r_min: ImVec2, r_max: ImVec2, clip: bool = true) -> bool {
        IsMouseHoveringRect_internal :: (r_min: *ImVec2, r_max: *ImVec2, clip: bool) -> bool #foreign imgui "?IsMouseHoveringRect@ImGui@@YA_NAEBUImVec2@@0_N@Z";
        return IsMouseHoveringRect_internal(*r_min, *r_max, clip);
    }
    IsMousePosValid :: (mouse_pos: *ImVec2 = null) -> bool #foreign imgui "?IsMousePosValid@ImGui@@YA_NPEBUImVec2@@@Z";
    IsAnyMouseDown :: () -> bool #foreign imgui "?IsAnyMouseDown@ImGui@@YA_NXZ";
    GetMousePos :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetMousePos@ImGui@@YA?AUImVec2@@XZ";
    GetMousePosOnOpeningCurrentPopup :: () -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetMousePosOnOpeningCurrentPopup@ImGui@@YA?AUImVec2@@XZ";
    IsMouseDragging :: (button: MouseButton, lock_threshold: float = -1.0) -> bool #foreign imgui "?IsMouseDragging@ImGui@@YA_NHM@Z";
    GetMouseDragDelta :: (button: MouseButton = .Left, lock_threshold: float = -1.0) -> ImVec2 #cpp_return_type_is_non_pod #foreign imgui "?GetMouseDragDelta@ImGui@@YA?AUImVec2@@HM@Z";
    ResetMouseDragDelta :: (button: MouseButton = .Left) -> void #foreign imgui "?ResetMouseDragDelta@ImGui@@YAXH@Z";
    GetMouseCursor :: () -> MouseCursor #foreign imgui "?GetMouseCursor@ImGui@@YAHXZ";
    SetMouseCursor :: (cursor_type: MouseCursor) -> void #foreign imgui "?SetMouseCursor@ImGui@@YAXH@Z";
    CaptureMouseFromApp :: (want_capture_mouse_value: bool = true) -> void #foreign imgui "?CaptureMouseFromApp@ImGui@@YAX_N@Z";
    GetClipboardText :: () -> *u8 #foreign imgui "?GetClipboardText@ImGui@@YAPEBDXZ";
    SetClipboardText :: (text: *u8) -> void #foreign imgui "?SetClipboardText@ImGui@@YAXPEBD@Z";
    LoadIniSettingsFromDisk :: (ini_filename: *u8) -> void #foreign imgui "?LoadIniSettingsFromDisk@ImGui@@YAXPEBD@Z";
    LoadIniSettingsFromMemory :: (ini_data: *u8, ini_size: size_t) -> void #foreign imgui "?LoadIniSettingsFromMemory@ImGui@@YAXPEBD_K@Z";
    SaveIniSettingsToDisk :: (ini_filename: *u8) -> void #foreign imgui "?SaveIniSettingsToDisk@ImGui@@YAXPEBD@Z";
    SaveIniSettingsToMemory :: (out_ini_size: *size_t = null) -> *u8 #foreign imgui "?SaveIniSettingsToMemory@ImGui@@YAPEBDPEA_K@Z";
    DebugCheckVersionAndDataLayout :: (version_str: *u8, sz_io: size_t, sz_style: size_t, sz_vec2: size_t, sz_vec4: size_t, sz_drawvert: size_t, sz_drawidx: size_t) -> bool #foreign imgui "?DebugCheckVersionAndDataLayout@ImGui@@YA_NPEBD_K11111@Z";
    SetAllocatorFunctions :: (alloc_func: MemAllocFunc, free_func: MemFreeFunc, user_data: *void = null) -> void #foreign imgui "?SetAllocatorFunctions@ImGui@@YAXP6APEAX_KPEAX@ZP6AX11@Z1@Z";
    GetAllocatorFunctions :: (p_alloc_func: *MemAllocFunc, p_free_func: *MemFreeFunc, p_user_data: **void) -> void #foreign imgui "?GetAllocatorFunctions@ImGui@@YAXPEAP6APEAX_KPEAX@ZPEAP6AX11@ZPEAPEAX@Z";
    MemAlloc :: (size: size_t) -> *void #foreign imgui "?MemAlloc@ImGui@@YAPEAX_K@Z";
    MemFree :: (ptr: *void) -> void #foreign imgui "?MemFree@ImGui@@YAXPEAX@Z";
    GetPlatformIO :: () -> *PlatformIO #foreign imgui "?GetPlatformIO@ImGui@@YAAEAUImGuiPlatformIO@@XZ";
    UpdatePlatformWindows :: () -> void #foreign imgui "?UpdatePlatformWindows@ImGui@@YAXXZ";
    RenderPlatformWindowsDefault :: (platform_render_arg: *void = null, renderer_render_arg: *void = null) -> void #foreign imgui "?RenderPlatformWindowsDefault@ImGui@@YAXPEAX0@Z";
    DestroyPlatformWindows :: () -> void #foreign imgui "?DestroyPlatformWindows@ImGui@@YAXXZ";
    FindViewportByID :: (id: ID) -> *Viewport #foreign imgui "?FindViewportByID@ImGui@@YAPEAUImGuiViewport@@I@Z";
    FindViewportByPlatformHandle :: (platform_handle: *void) -> *Viewport #foreign imgui "?FindViewportByPlatformHandle@ImGui@@YAPEAUImGuiViewport@@PEAX@Z";
// }

WindowFlags :: enum s32 {
    None :: 0;
    NoTitleBar :: 1;
    NoResize :: 2;
    NoMove :: 4;
    NoScrollbar :: 8;
    NoScrollWithMouse :: 16;
    NoCollapse :: 32;
    AlwaysAutoResize :: 64;
    NoBackground :: 128;
    NoSavedSettings :: 256;
    NoMouseInputs :: 512;
    MenuBar :: 1024;
    HorizontalScrollbar :: 2048;
    NoFocusOnAppearing :: 4096;
    NoBringToFrontOnFocus :: 8192;
    AlwaysVerticalScrollbar :: 16384;
    AlwaysHorizontalScrollbar :: 32768;
    AlwaysUseWindowPadding :: 65536;
    NoNavInputs :: 262144;
    NoNavFocus :: 524288;
    UnsavedDocument :: 1048576;
    NoDocking :: 2097152;
    NoNav :: 786432;
    NoDecoration :: 43;
    NoInputs :: 786944;
    NavFlattened :: 8388608;
    ChildWindow :: 16777216;
    Tooltip :: 33554432;
    Popup :: 67108864;
    Modal :: 134217728;
    ChildMenu :: 268435456;
    DockNodeHost :: 536870912;
}

InputTextFlags :: enum s32 {
    None :: 0;
    CharsDecimal :: 1;
    CharsHexadecimal :: 2;
    CharsUppercase :: 4;
    CharsNoBlank :: 8;
    AutoSelectAll :: 16;
    EnterReturnsTrue :: 32;
    CallbackCompletion :: 64;
    CallbackHistory :: 128;
    CallbackAlways :: 256;
    CallbackCharFilter :: 512;
    AllowTabInput :: 1024;
    CtrlEnterForNewLine :: 2048;
    NoHorizontalScroll :: 4096;
    AlwaysOverwrite :: 8192;
    ReadOnly :: 16384;
    Password :: 32768;
    NoUndoRedo :: 65536;
    CharsScientific :: 131072;
    CallbackResize :: 262144;
    CallbackEdit :: 524288;
}

TreeNodeFlags :: enum s32 {
    None :: 0;
    Selected :: 1;
    Framed :: 2;
    AllowItemOverlap :: 4;
    NoTreePushOnOpen :: 8;
    NoAutoOpenOnLog :: 16;
    DefaultOpen :: 32;
    OpenOnDoubleClick :: 64;
    OpenOnArrow :: 128;
    Leaf :: 256;
    Bullet :: 512;
    FramePadding :: 1024;
    SpanAvailWidth :: 2048;
    SpanFullWidth :: 4096;
    NavLeftJumpsBackHere :: 8192;
    CollapsingHeader :: 26;
}

PopupFlags :: enum s32 {
    None :: 0;
    MouseButtonLeft :: 0;
    MouseButtonRight :: 1;
    MouseButtonMiddle :: 2;
    MouseButtonMask_ :: 31;
    MouseButtonDefault_ :: 1;
    NoOpenOverExistingPopup :: 32;
    NoOpenOverItems :: 64;
    AnyPopupId :: 128;
    AnyPopupLevel :: 256;
    AnyPopup :: 384;
}

SelectableFlags :: enum s32 {
    None :: 0;
    DontClosePopups :: 1;
    SpanAllColumns :: 2;
    AllowDoubleClick :: 4;
    Disabled :: 8;
    AllowItemOverlap :: 16;
}

ComboFlags :: enum s32 {
    None :: 0;
    PopupAlignLeft :: 1;
    HeightSmall :: 2;
    HeightRegular :: 4;
    HeightLarge :: 8;
    HeightLargest :: 16;
    NoArrowButton :: 32;
    NoPreview :: 64;
    HeightMask_ :: 30;
}

TabBarFlags :: enum s32 {
    None :: 0;
    Reorderable :: 1;
    AutoSelectNewTabs :: 2;
    TabListPopupButton :: 4;
    NoCloseWithMiddleMouseButton :: 8;
    NoTabListScrollingButtons :: 16;
    NoTooltip :: 32;
    FittingPolicyResizeDown :: 64;
    FittingPolicyScroll :: 128;
    FittingPolicyMask_ :: 192;
    FittingPolicyDefault_ :: 64;
}

TabItemFlags :: enum s32 {
    None :: 0;
    UnsavedDocument :: 1;
    SetSelected :: 2;
    NoCloseWithMiddleMouseButton :: 4;
    NoPushId :: 8;
    NoTooltip :: 16;
    NoReorder :: 32;
    Leading :: 64;
    Trailing :: 128;
}

TableFlags :: enum s32 {
    None :: 0;
    Resizable :: 1;
    Reorderable :: 2;
    Hideable :: 4;
    Sortable :: 8;
    NoSavedSettings :: 16;
    ContextMenuInBody :: 32;
    RowBg :: 64;
    BordersInnerH :: 128;
    BordersOuterH :: 256;
    BordersInnerV :: 512;
    BordersOuterV :: 1024;
    BordersH :: 384;
    BordersV :: 1536;
    BordersInner :: 640;
    BordersOuter :: 1280;
    Borders :: 1920;
    NoBordersInBody :: 2048;
    NoBordersInBodyUntilResize :: 4096;
    SizingFixedFit :: 8192;
    SizingFixedSame :: 16384;
    SizingStretchProp :: 24576;
    SizingStretchSame :: 32768;
    NoHostExtendX :: 65536;
    NoHostExtendY :: 131072;
    NoKeepColumnsVisible :: 262144;
    PreciseWidths :: 524288;
    NoClip :: 1048576;
    PadOuterX :: 2097152;
    NoPadOuterX :: 4194304;
    NoPadInnerX :: 8388608;
    ScrollX :: 16777216;
    ScrollY :: 33554432;
    SortMulti :: 67108864;
    SortTristate :: 134217728;
    SizingMask_ :: 57344;
}

TableColumnFlags :: enum s32 {
    None :: 0;
    Disabled :: 1;
    DefaultHide :: 2;
    DefaultSort :: 4;
    WidthStretch :: 8;
    WidthFixed :: 16;
    NoResize :: 32;
    NoReorder :: 64;
    NoHide :: 128;
    NoClip :: 256;
    NoSort :: 512;
    NoSortAscending :: 1024;
    NoSortDescending :: 2048;
    NoHeaderLabel :: 4096;
    NoHeaderWidth :: 8192;
    PreferSortAscending :: 16384;
    PreferSortDescending :: 32768;
    IndentEnable :: 65536;
    IndentDisable :: 131072;
    IsEnabled :: 16777216;
    IsVisible :: 33554432;
    IsSorted :: 67108864;
    IsHovered :: 134217728;
    WidthMask_ :: 24;
    IndentMask_ :: 196608;
    StatusMask_ :: 251658240;
    NoDirectResize_ :: 1073741824;
}

TableRowFlags :: enum s32 {
    None :: 0;
    Headers :: 1;
}

TableBgTarget :: enum s32 {
    None :: 0;
    RowBg0 :: 1;
    RowBg1 :: 2;
    CellBg :: 3;
}

FocusedFlags :: enum s32 {
    None :: 0;
    ChildWindows :: 1;
    RootWindow :: 2;
    AnyWindow :: 4;
    RootAndChildWindows :: 3;
}

HoveredFlags :: enum s32 {
    None :: 0;
    ChildWindows :: 1;
    RootWindow :: 2;
    AnyWindow :: 4;
    AllowWhenBlockedByPopup :: 8;
    AllowWhenBlockedByActiveItem :: 32;
    AllowWhenOverlapped :: 64;
    AllowWhenDisabled :: 128;
    RectOnly :: 104;
    RootAndChildWindows :: 3;
}

DockNodeFlags :: enum s32 {
    None :: 0;
    KeepAliveOnly :: 1;
    NoDockingInCentralNode :: 4;
    PassthruCentralNode :: 8;
    NoSplit :: 16;
    NoResize :: 32;
    AutoHideTabBar :: 64;
}

DragDropFlags :: enum s32 {
    None :: 0;
    SourceNoPreviewTooltip :: 1;
    SourceNoDisableHover :: 2;
    SourceNoHoldToOpenOthers :: 4;
    SourceAllowNullID :: 8;
    SourceExtern :: 16;
    SourceAutoExpirePayload :: 32;
    AcceptBeforeDelivery :: 1024;
    AcceptNoDrawDefaultRect :: 2048;
    AcceptNoPreviewTooltip :: 4096;
    AcceptPeekOnly :: 3072;
}

DataType :: enum s32 {
    S8 :: 0;
    U8 :: 1;
    S16 :: 2;
    U16 :: 3;
    S32 :: 4;
    U32 :: 5;
    S64 :: 6;
    U64 :: 7;
    Float :: 8;
    Double :: 9;
    COUNT :: 10;
}

Dir :: enum s32 {
    None :: -1;
    Left :: 0;
    Right :: 1;
    Up :: 2;
    Down :: 3;
    COUNT :: 4;
}

SortDirection :: enum s32 {
    None :: 0;
    Ascending :: 1;
    Descending :: 2;
}

Key :: enum s32 {
    Tab :: 0;
    LeftArrow :: 1;
    RightArrow :: 2;
    UpArrow :: 3;
    DownArrow :: 4;
    PageUp :: 5;
    PageDown :: 6;
    Home :: 7;
    End :: 8;
    Insert :: 9;
    Delete :: 10;
    Backspace :: 11;
    Space :: 12;
    Enter :: 13;
    Escape :: 14;
    KeyPadEnter :: 15;
    A :: 16;
    C :: 17;
    V :: 18;
    X :: 19;
    Y :: 20;
    Z :: 21;
    COUNT :: 22;
}

KeyModFlags :: enum s32 {
    None :: 0;
    Ctrl :: 1;
    Shift :: 2;
    Alt :: 4;
    Super :: 8;
}

NavInput_ :: enum s32 {
    Activate :: 0;
    Cancel :: 1;
    Input :: 2;
    Menu :: 3;
    DpadLeft :: 4;
    DpadRight :: 5;
    DpadUp :: 6;
    DpadDown :: 7;
    LStickLeft :: 8;
    LStickRight :: 9;
    LStickUp :: 10;
    LStickDown :: 11;
    FocusPrev :: 12;
    FocusNext :: 13;
    TweakSlow :: 14;
    TweakFast :: 15;
    KeyMenu_ :: 16;
    KeyLeft_ :: 17;
    KeyRight_ :: 18;
    KeyUp_ :: 19;
    KeyDown_ :: 20;
    COUNT :: 21;
    InternalStart_ :: 16;
}

ConfigFlags :: enum s32 {
    None :: 0;
    NavEnableKeyboard :: 1;
    NavEnableGamepad :: 2;
    NavEnableSetMousePos :: 4;
    NavNoCaptureKeyboard :: 8;
    NoMouse :: 16;
    NoMouseCursorChange :: 32;
    DockingEnable :: 64;
    ViewportsEnable :: 1024;
    DpiEnableScaleViewports :: 16384;
    DpiEnableScaleFonts :: 32768;
    IsSRGB :: 1048576;
    IsTouchScreen :: 2097152;
}

BackendFlags :: enum s32 {
    None :: 0;
    HasGamepad :: 1;
    HasMouseCursors :: 2;
    HasSetMousePos :: 4;
    RendererHasVtxOffset :: 8;
    PlatformHasViewports :: 1024;
    HasMouseHoveredViewport :: 2048;
    RendererHasViewports :: 4096;
}

Col :: enum s32 {
    Text :: 0;
    TextDisabled :: 1;
    WindowBg :: 2;
    ChildBg :: 3;
    PopupBg :: 4;
    Border :: 5;
    BorderShadow :: 6;
    FrameBg :: 7;
    FrameBgHovered :: 8;
    FrameBgActive :: 9;
    TitleBg :: 10;
    TitleBgActive :: 11;
    TitleBgCollapsed :: 12;
    MenuBarBg :: 13;
    ScrollbarBg :: 14;
    ScrollbarGrab :: 15;
    ScrollbarGrabHovered :: 16;
    ScrollbarGrabActive :: 17;
    CheckMark :: 18;
    SliderGrab :: 19;
    SliderGrabActive :: 20;
    Button :: 21;
    ButtonHovered :: 22;
    ButtonActive :: 23;
    Header :: 24;
    HeaderHovered :: 25;
    HeaderActive :: 26;
    Separator :: 27;
    SeparatorHovered :: 28;
    SeparatorActive :: 29;
    ResizeGrip :: 30;
    ResizeGripHovered :: 31;
    ResizeGripActive :: 32;
    Tab :: 33;
    TabHovered :: 34;
    TabActive :: 35;
    TabUnfocused :: 36;
    TabUnfocusedActive :: 37;
    DockingPreview :: 38;
    DockingEmptyBg :: 39;
    PlotLines :: 40;
    PlotLinesHovered :: 41;
    PlotHistogram :: 42;
    PlotHistogramHovered :: 43;
    TableHeaderBg :: 44;
    TableBorderStrong :: 45;
    TableBorderLight :: 46;
    TableRowBg :: 47;
    TableRowBgAlt :: 48;
    TextSelectedBg :: 49;
    DragDropTarget :: 50;
    NavHighlight :: 51;
    NavWindowingHighlight :: 52;
    NavWindowingDimBg :: 53;
    ModalWindowDimBg :: 54;
    COUNT :: 55;
}

StyleVar :: enum s32 {
    Alpha :: 0;
    WindowPadding :: 1;
    WindowRounding :: 2;
    WindowBorderSize :: 3;
    WindowMinSize :: 4;
    WindowTitleAlign :: 5;
    ChildRounding :: 6;
    ChildBorderSize :: 7;
    PopupRounding :: 8;
    PopupBorderSize :: 9;
    FramePadding :: 10;
    FrameRounding :: 11;
    FrameBorderSize :: 12;
    ItemSpacing :: 13;
    ItemInnerSpacing :: 14;
    IndentSpacing :: 15;
    CellPadding :: 16;
    ScrollbarSize :: 17;
    ScrollbarRounding :: 18;
    GrabMinSize :: 19;
    GrabRounding :: 20;
    TabRounding :: 21;
    ButtonTextAlign :: 22;
    SelectableTextAlign :: 23;
    COUNT :: 24;
}

ButtonFlags :: enum s32 {
    None :: 0;
    MouseButtonLeft :: 1;
    MouseButtonRight :: 2;
    MouseButtonMiddle :: 4;
    MouseButtonMask_ :: 7;
    MouseButtonDefault_ :: 1;
}

ColorEditFlags :: enum s32 {
    None :: 0;
    NoAlpha :: 2;
    NoPicker :: 4;
    NoOptions :: 8;
    NoSmallPreview :: 16;
    NoInputs :: 32;
    NoTooltip :: 64;
    NoLabel :: 128;
    NoSidePreview :: 256;
    NoDragDrop :: 512;
    NoBorder :: 1024;
    AlphaBar :: 65536;
    AlphaPreview :: 131072;
    AlphaPreviewHalf :: 262144;
    HDR :: 524288;
    DisplayRGB :: 1048576;
    DisplayHSV :: 2097152;
    DisplayHex :: 4194304;
    Uint8 :: 8388608;
    Float :: 16777216;
    PickerHueBar :: 33554432;
    PickerHueWheel :: 67108864;
    InputRGB :: 134217728;
    InputHSV :: 268435456;
    OptionsDefault :: 177209344;
    DisplayMask :: 7340032;
    DataTypeMask :: 25165824;
    PickerMask :: 100663296;
    InputMask :: 402653184;
}

SliderFlags :: enum s32 {
    None :: 0;
    AlwaysClamp :: 16;
    Logarithmic :: 32;
    NoRoundToFormat :: 64;
    NoInput :: 128;
    InvalidMask_ :: 1879048207;
}

MouseButton :: enum s32 {
    Left :: 0;
    Right :: 1;
    Middle :: 2;
    COUNT :: 5;
}

MouseCursor :: enum s32 {
    None :: -1;
    Arrow :: 0;
    TextInput :: 1;
    ResizeAll :: 2;
    ResizeNS :: 3;
    ResizeEW :: 4;
    ResizeNESW :: 5;
    ResizeNWSE :: 6;
    Hand :: 7;
    NotAllowed :: 8;
    COUNT :: 9;
}

Cond :: enum s32 {
    None :: 0;
    Always :: 1;
    Once :: 2;
    FirstUseEver :: 4;
    Appearing :: 8;
}

ImNewWrapper :: struct {
__empty_struct_padding: u8; // C++ makes empty structs have length 1
}
// #run check_size(ImNewWrapper, 1);

/* (jaicc: omitted inline function)
operator_new :: (unk0: size_t, unk1: ImNewWrapper, ptr: *void) -> *void #c_call {
}
*/


/* (jaicc: omitted inline function)
operator_delete :: (unk0: *void, unk1: ImNewWrapper, unk2: *void) -> void #c_call {
}
*/


ImVector :: struct(T: Type) {
    Size: s32;
    Capacity: s32;
    Data: *T;
    value_type :: T;
    iterator :: *value_type;
    const_iterator :: *value_type;
}

Style :: struct {
    Alpha: float;
    WindowPadding: ImVec2;
    WindowRounding: float;
    WindowBorderSize: float;
    WindowMinSize: ImVec2;
    WindowTitleAlign: ImVec2;
    WindowMenuButtonPosition: Dir;
    ChildRounding: float;
    ChildBorderSize: float;
    PopupRounding: float;
    PopupBorderSize: float;
    FramePadding: ImVec2;
    FrameRounding: float;
    FrameBorderSize: float;
    ItemSpacing: ImVec2;
    ItemInnerSpacing: ImVec2;
    CellPadding: ImVec2;
    TouchExtraPadding: ImVec2;
    IndentSpacing: float;
    ColumnsMinSpacing: float;
    ScrollbarSize: float;
    ScrollbarRounding: float;
    GrabMinSize: float;
    GrabRounding: float;
    LogSliderDeadzone: float;
    TabRounding: float;
    TabBorderSize: float;
    TabMinWidthForCloseButton: float;
    ColorButtonPosition: Dir;
    ButtonTextAlign: ImVec2;
    SelectableTextAlign: ImVec2;
    DisplayWindowPadding: ImVec2;
    DisplaySafeAreaPadding: ImVec2;
    MouseCursorScale: float;
    AntiAliasedLines: bool;
    AntiAliasedLinesUseTex: bool;
    AntiAliasedFill: bool;
    CurveTessellationTol: float;
    CircleTessellationMaxError: float;
    Colors: [55] ImVec4;
    ScaleAllSizes :: (this: *Style, scale_factor: float) -> void #cpp_method #foreign imgui "?ScaleAllSizes@ImGuiStyle@@QEAAXM@Z";
}
// #run check_size(Style, 1076);

IO :: struct {
    ConfigFlags_: ConfigFlags;
    BackendFlags_: BackendFlags;
    DisplaySize: ImVec2;
    DeltaTime: float;
    IniSavingRate: float;
    IniFilename: *u8;
    LogFilename: *u8;
    MouseDoubleClickTime: float;
    MouseDoubleClickMaxDist: float;
    MouseDragThreshold: float;
    KeyMap: [22] s32;
    KeyRepeatDelay: float;
    KeyRepeatRate: float;
    UserData: *void;
    Fonts: *ImFontAtlas;
    FontGlobalScale: float;
    FontAllowUserScaling: bool;
    FontDefault: *ImFont;
    DisplayFramebufferScale: ImVec2;
    ConfigDockingNoSplit: bool;
    ConfigDockingAlwaysTabBar: bool;
    ConfigDockingTransparentPayload: bool;
    ConfigViewportsNoAutoMerge: bool;
    ConfigViewportsNoTaskBarIcon: bool;
    ConfigViewportsNoDecoration: bool;
    ConfigViewportsNoDefaultParent: bool;
    MouseDrawCursor: bool;
    ConfigMacOSXBehaviors: bool;
    ConfigInputTextCursorBlink: bool;
    ConfigDragClickToInputText: bool;
    ConfigWindowsResizeFromEdges: bool;
    ConfigWindowsMoveFromTitleBarOnly: bool;
    ConfigMemoryCompactTimer: float;
    BackendPlatformName: *u8;
    BackendRendererName: *u8;
    BackendPlatformUserData: *void;
    BackendRendererUserData: *void;
    BackendLanguageUserData: *void;
    GetClipboardTextFn: #type (a0: *void) -> *u8 #c_call;
    SetClipboardTextFn: #type (a0: *void, a1: *u8) -> void #c_call;
    ClipboardUserData: *void;
    MousePos: ImVec2;
    MouseDown: [5] bool;
    MouseWheel: float;
    MouseWheelH: float;
    MouseHoveredViewport: ID;
    KeyCtrl: bool;
    KeyShift: bool;
    KeyAlt: bool;
    KeySuper: bool;
    KeysDown: [512] bool;
    NavInputs: [21] float;
    AddInputCharacter :: (this: *IO, c: u32) -> void #cpp_method #foreign imgui "?AddInputCharacter@ImGuiIO@@QEAAXI@Z";
    AddInputCharacterUTF16 :: (this: *IO, c: ImWchar16) -> void #cpp_method #foreign imgui "?AddInputCharacterUTF16@ImGuiIO@@QEAAXG@Z";
    AddInputCharactersUTF8 :: (this: *IO, str: *u8) -> void #cpp_method #foreign imgui "?AddInputCharactersUTF8@ImGuiIO@@QEAAXPEBD@Z";
    ClearInputCharacters :: (this: *IO) -> void #cpp_method #foreign imgui "?ClearInputCharacters@ImGuiIO@@QEAAXXZ";
    WantCaptureMouse: bool;
    WantCaptureKeyboard: bool;
    WantTextInput: bool;
    WantSetMousePos: bool;
    WantSaveIniSettings: bool;
    NavActive: bool;
    NavVisible: bool;
    Framerate: float;
    MetricsRenderVertices: s32;
    MetricsRenderIndices: s32;
    MetricsRenderWindows: s32;
    MetricsActiveWindows: s32;
    MetricsActiveAllocations: s32;
    MouseDelta: ImVec2;
    KeyMods: KeyModFlags;
    MousePosPrev: ImVec2;
    MouseClickedPos: [5] ImVec2;
    MouseClickedTime: [5] float64;
    MouseClicked: [5] bool;
    MouseDoubleClicked: [5] bool;
    MouseReleased: [5] bool;
    MouseDownOwned: [5] bool;
    MouseDownWasDoubleClick: [5] bool;
    MouseDownDuration: [5] float;
    MouseDownDurationPrev: [5] float;
    MouseDragMaxDistanceAbs: [5] ImVec2;
    MouseDragMaxDistanceSqr: [5] float;
    KeysDownDuration: [512] float;
    KeysDownDurationPrev: [512] float;
    NavInputsDownDuration: [21] float;
    NavInputsDownDurationPrev: [21] float;
    PenPressure: float;
    InputQueueSurrogate: ImWchar16;
    InputQueueCharacters: ImVector(u16);
}
// #run check_size(IO, 5456);

InputTextCallbackData :: struct {
    EventFlag: InputTextFlags;
    Flags: InputTextFlags;
    UserData: *void;
    EventChar: ImWchar;
    EventKey: Key;
    Buf: *u8;
    BufTextLen: s32;
    BufSize: s32;
    BufDirty: bool;
    CursorPos: s32;
    SelectionStart: s32;
    SelectionEnd: s32;
    DeleteChars :: (this: *InputTextCallbackData, pos: s32, bytes_count: s32) -> void #cpp_method #foreign imgui "?DeleteChars@ImGuiInputTextCallbackData@@QEAAXHH@Z";
    InsertChars :: (this: *InputTextCallbackData, pos: s32, text: string) {
        InsertChars_internal :: (this: *InputTextCallbackData, pos: s32, text: *u8, text_end: *u8) -> void #cpp_method #foreign imgui "?InsertChars@ImGuiInputTextCallbackData@@QEAAXHPEBD0@Z";
        InsertChars_internal(this, pos, text.data, text.data + text.count);
    }
    /* (jaicc: omitted inline function)
    SelectAll :: (this: *InputTextCallbackData) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    ClearSelection :: (this: *InputTextCallbackData) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    HasSelection :: (this: *InputTextCallbackData) -> bool #cpp_method {
    }
    */

}
// #run check_size(InputTextCallbackData, 56);

SizeCallbackData :: struct {
    UserData: *void;
    Pos: ImVec2;
    CurrentSize: ImVec2;
    DesiredSize: ImVec2;
}
// #run check_size(SizeCallbackData, 32);

WindowClass :: struct {
    ClassId: ID;
    ParentViewportId: ID;
    ViewportFlagsOverrideSet: ViewportFlags;
    ViewportFlagsOverrideClear: ViewportFlags;
    TabItemFlagsOverrideSet: TabItemFlags;
    DockNodeFlagsOverrideSet: DockNodeFlags;
    DockNodeFlagsOverrideClear: DockNodeFlags;
    DockingAlwaysTabBar: bool;
    DockingAllowUnclassed: bool;
}
// #run check_size(WindowClass, 32);

Payload :: struct {
    Data: *void;
    DataSize: s32;
    SourceId: ID;
    SourceParentId: ID;
    DataFrameCount: s32;
    DataType_: [33] u8;
    Preview: bool;
    Delivery: bool;
    /* (jaicc: omitted inline function)
    Clear :: (this: *Payload) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    IsDataType :: (this: *Payload, type: *u8) -> bool #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    IsPreview :: (this: *Payload) -> bool #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    IsDelivery :: (this: *Payload) -> bool #cpp_method {
    }
    */

}
// #run check_size(Payload, 64);

TableColumnSortSpecs :: struct {
    ColumnUserID: ID;
    ColumnIndex: ImS16;
    SortOrder: ImS16;
    SortDirection_: SortDirection;
}
// #run check_size(TableColumnSortSpecs, 12);

TableSortSpecs :: struct {
    Specs: *TableColumnSortSpecs;
    SpecsCount: s32;
    SpecsDirty: bool;
}
// #run check_size(TableSortSpecs, 16);

OnceUponAFrame :: struct {
    RefFrame: s32;
}
// #run check_size(OnceUponAFrame, 4);

TextFilter :: struct {
    Draw :: (this: *TextFilter, label: *u8 = "Filter (inc,-exc)", width: float = 0.0) -> bool #cpp_method #foreign imgui "?Draw@ImGuiTextFilter@@QEAA_NPEBDM@Z";
    PassFilter :: (this: *TextFilter, text: string) -> bool {
        PassFilter_internal :: (this: *TextFilter, text: *u8, text_end: *u8) -> bool #cpp_method #foreign imgui "?PassFilter@ImGuiTextFilter@@QEBA_NPEBD0@Z";
        return PassFilter_internal(this, text.data, text.data + text.count);
    }
    Build :: (this: *TextFilter) -> void #cpp_method #foreign imgui "?Build@ImGuiTextFilter@@QEAAXXZ";
    /* (jaicc: omitted inline function)
    Clear :: (this: *TextFilter) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    IsActive :: (this: *TextFilter) -> bool #cpp_method {
    }
    */

    TextRange :: struct {
        b: *u8;
        e: *u8;
        /* (jaicc: omitted inline function)
        empty :: (this: *TextRange) -> bool #cpp_method {
        }
        */

        split :: (this: *TextRange, separator: u8, out: **ImVector(TextFilter.TextRange)) -> void #cpp_method #foreign imgui "?split@ImGuiTextRange@ImGuiTextFilter@@QEBAXDPEAU?$ImVector@UImGuiTextRange@ImGuiTextFilter@@@@@Z";
    }
// #run check_size(TextRange, 16);
    InputBuf: [256] u8;
    Filters: ImVector(TextFilter.TextRange);
    CountGrep: s32;
}
// #run check_size(TextFilter, 280);

TextBuffer :: struct {
    Buf: ImVector(s8);
    /* (jaicc: omitted inline function)
    operator[] :: (this: *TextBuffer, i: s32) -> u8 #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    begin :: (this: *TextBuffer) -> *u8 #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    end :: (this: *TextBuffer) -> *u8 #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    size :: (this: *TextBuffer) -> s32 #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    empty :: (this: *TextBuffer) -> bool #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    clear :: (this: *TextBuffer) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    reserve :: (this: *TextBuffer, capacity: s32) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    c_str :: (this: *TextBuffer) -> *u8 #cpp_method {
    }
    */

    append :: (this: *TextBuffer, str: string) {
        append_internal :: (this: *TextBuffer, str: *u8, str_end: *u8) -> void #cpp_method #foreign imgui "?append@ImGuiTextBuffer@@QEAAXPEBD0@Z";
        append_internal(this, str.data, str.data + str.count);
    }
    appendf :: (this: *TextBuffer, fmt: *u8, __args: ..Any) -> void #cpp_method #foreign imgui "?appendf@ImGuiTextBuffer@@QEAAXPEBDZZ";
    /* (jaicc: omitted function with valist)
    appendfv :: (this: *TextBuffer, fmt: *u8, args: va_list) -> void #cpp_method #foreign imgui "?appendfv@ImGuiTextBuffer@@QEAAXPEBDPEAD@Z";
    */

}
// #run check_size(TextBuffer, 16);

Storage :: struct {
    StoragePair :: struct {
        key: ID;
        union {
            val_i: s32;
            val_f: float;
            val_p: *void;
        }
    }
// #run check_size(StoragePair, 16);
    Data: ImVector(Storage.StoragePair);
    /* (jaicc: omitted inline function)
    Clear :: (this: *Storage) -> void #cpp_method {
    }
    */

    GetInt :: (this: *Storage, key: ID, default_val: s32 = 0) -> s32 #cpp_method #foreign imgui "?GetInt@ImGuiStorage@@QEBAHIH@Z";
    SetInt :: (this: *Storage, key: ID, val: s32) -> void #cpp_method #foreign imgui "?SetInt@ImGuiStorage@@QEAAXIH@Z";
    GetBool :: (this: *Storage, key: ID, default_val: bool = false) -> bool #cpp_method #foreign imgui "?GetBool@ImGuiStorage@@QEBA_NI_N@Z";
    SetBool :: (this: *Storage, key: ID, val: bool) -> void #cpp_method #foreign imgui "?SetBool@ImGuiStorage@@QEAAXI_N@Z";
    GetFloat :: (this: *Storage, key: ID, default_val: float = 0.0) -> float #cpp_method #foreign imgui "?GetFloat@ImGuiStorage@@QEBAMIM@Z";
    SetFloat :: (this: *Storage, key: ID, val: float) -> void #cpp_method #foreign imgui "?SetFloat@ImGuiStorage@@QEAAXIM@Z";
    GetVoidPtr :: (this: *Storage, key: ID) -> *void #cpp_method #foreign imgui "?GetVoidPtr@ImGuiStorage@@QEBAPEAXI@Z";
    SetVoidPtr :: (this: *Storage, key: ID, val: *void) -> void #cpp_method #foreign imgui "?SetVoidPtr@ImGuiStorage@@QEAAXIPEAX@Z";
    GetIntRef :: (this: *Storage, key: ID, default_val: s32 = 0) -> *s32 #cpp_method #foreign imgui "?GetIntRef@ImGuiStorage@@QEAAPEAHIH@Z";
    GetBoolRef :: (this: *Storage, key: ID, default_val: bool = false) -> *bool #cpp_method #foreign imgui "?GetBoolRef@ImGuiStorage@@QEAAPEA_NI_N@Z";
    GetFloatRef :: (this: *Storage, key: ID, default_val: float = 0.0) -> *float #cpp_method #foreign imgui "?GetFloatRef@ImGuiStorage@@QEAAPEAMIM@Z";
    GetVoidPtrRef :: (this: *Storage, key: ID, default_val: *void = null) -> **void #cpp_method #foreign imgui "?GetVoidPtrRef@ImGuiStorage@@QEAAPEAPEAXIPEAX@Z";
    SetAllInt :: (this: *Storage, val: s32) -> void #cpp_method #foreign imgui "?SetAllInt@ImGuiStorage@@QEAAXH@Z";
    BuildSortByKey :: (this: *Storage) -> void #cpp_method #foreign imgui "?BuildSortByKey@ImGuiStorage@@QEAAXXZ";
}
// #run check_size(Storage, 16);

ListClipper :: struct {
    DisplayStart: s32;
    DisplayEnd: s32;
    ItemsCount: s32;
    StepNo: s32;
    ItemsFrozen: s32;
    ItemsHeight: float;
    StartPosY: float;
    /* (jaicc: function missing foreign lib)
    Destructor :: (this: *ListClipper) -> void #cpp_method #foreign __UnknownLib "??_DImGuiListClipper@@QEAAXXZ";
    */

    Begin :: (this: *ListClipper, items_count: s32, items_height: float = -1.0) -> void #cpp_method #foreign imgui "?Begin@ImGuiListClipper@@QEAAXHM@Z";
    End :: (this: *ListClipper) -> void #cpp_method #foreign imgui "?End@ImGuiListClipper@@QEAAXXZ";
    Step :: (this: *ListClipper) -> bool #cpp_method #foreign imgui "?Step@ImGuiListClipper@@QEAA_NXZ";
}
// #run check_size(ListClipper, 28);

ImColor :: struct {
    Value: ImVec4;
    /* (jaicc: omitted inline function)
    SetHSV :: (this: *ImColor, h: float, s: float, v: float, a: float = 1.0) -> void #cpp_method {
    }
    */

}
// #run check_size(ImColor, 16);

ImDrawCallback :: #type (a0: *ImDrawList, a1: *ImDrawCmd) -> void #c_call;

ImDrawCmd :: struct {
    ClipRect: ImVec4;
    TextureId: ImTextureID;
    VtxOffset: u32;
    IdxOffset: u32;
    ElemCount: u32;
    UserCallback: ImDrawCallback;
    UserCallbackData: *void;
    /* (jaicc: omitted inline function)
    GetTexID :: (this: *ImDrawCmd) -> ImTextureID #cpp_method {
    }
    */

}
// #run check_size(ImDrawCmd, 56);

ImDrawIdx :: u16;

ImDrawVert :: struct {
    pos: ImVec2;
    uv: ImVec2;
    col: ImU32;
}
// #run check_size(ImDrawVert, 20);

ImDrawCmdHeader :: struct {
    ClipRect: ImVec4;
    TextureId: ImTextureID;
    VtxOffset: u32;
}
// #run check_size(ImDrawCmdHeader, 32);

ImDrawChannel :: struct {
    _CmdBuffer: ImVector(ImDrawCmd);
    _IdxBuffer: ImVector(ImDrawIdx);
}
// #run check_size(ImDrawChannel, 32);

ImDrawListSplitter :: struct {
    _Current: s32;
    _Count: s32;
    _Channels: ImVector(ImDrawChannel);
    /* (jaicc: omitted inline function)
    Destructor :: (this: *ImDrawListSplitter) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    Clear :: (this: *ImDrawListSplitter) -> void #cpp_method {
    }
    */

    ClearFreeMemory :: (this: *ImDrawListSplitter) -> void #cpp_method #foreign imgui "?ClearFreeMemory@ImDrawListSplitter@@QEAAXXZ";
    Split :: (this: *ImDrawListSplitter, draw_list: *ImDrawList, count: s32) -> void #cpp_method #foreign imgui "?Split@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z";
    Merge :: (this: *ImDrawListSplitter, draw_list: *ImDrawList) -> void #cpp_method #foreign imgui "?Merge@ImDrawListSplitter@@QEAAXPEAUImDrawList@@@Z";
    SetCurrentChannel :: (this: *ImDrawListSplitter, draw_list: *ImDrawList, channel_idx: s32) -> void #cpp_method #foreign imgui "?SetCurrentChannel@ImDrawListSplitter@@QEAAXPEAUImDrawList@@H@Z";
}
// #run check_size(ImDrawListSplitter, 24);

ImDrawFlags :: enum s32 {
    None :: 0;
    Closed :: 1;
    RoundCornersTopLeft :: 16;
    RoundCornersTopRight :: 32;
    RoundCornersBottomLeft :: 64;
    RoundCornersBottomRight :: 128;
    RoundCornersNone :: 256;
    RoundCornersTop :: 48;
    RoundCornersBottom :: 192;
    RoundCornersLeft :: 80;
    RoundCornersRight :: 160;
    RoundCornersAll :: 240;
    RoundCornersDefault_ :: 240;
    RoundCornersMask_ :: 496;
}

ImDrawListFlags :: enum s32 {
    None :: 0;
    AntiAliasedLines :: 1;
    AntiAliasedLinesUseTex :: 2;
    AntiAliasedFill :: 4;
    AllowVtxOffset :: 8;
}

ImDrawList :: struct {
    CmdBuffer: ImVector(ImDrawCmd);
    IdxBuffer: ImVector(ImDrawIdx);
    VtxBuffer: ImVector(ImDrawVert);
    Flags: ImDrawListFlags;
    _VtxCurrentIdx: u32;
    _Data: *ImDrawListSharedData;
    _OwnerName: *u8;
    _VtxWritePtr: *ImDrawVert;
    _IdxWritePtr: *ImDrawIdx;
    _ClipRectStack: ImVector(ImVec4);
    _TextureIdStack: ImVector(ImTextureID);
    _Path: ImVector(ImVec2);
    _CmdHeader: ImDrawCmdHeader;
    _Splitter: ImDrawListSplitter;
    _FringeScale: float;
    /* (jaicc: omitted inline function)
    Destructor :: (this: *ImDrawList) -> void #cpp_method {
    }
    */

    PushClipRect :: (this: *ImDrawList, clip_rect_min: ImVec2, clip_rect_max: ImVec2, intersect_with_current_clip_rect: bool = false) -> void #cpp_method #foreign imgui "?PushClipRect@ImDrawList@@QEAAXUImVec2@@0_N@Z";
    PushClipRectFullScreen :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?PushClipRectFullScreen@ImDrawList@@QEAAXXZ";
    PopClipRect :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?PopClipRect@ImDrawList@@QEAAXXZ";
    PushTextureID :: (this: *ImDrawList, texture_id: ImTextureID) -> void #cpp_method #foreign imgui "?PushTextureID@ImDrawList@@QEAAXPEAX@Z";
    PopTextureID :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?PopTextureID@ImDrawList@@QEAAXXZ";
    /* (jaicc: omitted inline function)
    GetClipRectMin :: (this: *ImDrawList) -> ImVec2 #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    GetClipRectMax :: (this: *ImDrawList) -> ImVec2 #cpp_method {
    }
    */

    AddLine :: (this: *ImDrawList, p1: ImVec2, p2: ImVec2, col: ImU32, thickness: float = 1.0) {
        AddLine_internal :: (this: *ImDrawList, p1: *ImVec2, p2: *ImVec2, col: ImU32, thickness: float) -> void #cpp_method #foreign imgui "?AddLine@ImDrawList@@QEAAXAEBUImVec2@@0IM@Z";
        AddLine_internal(this, *p1, *p2, col, thickness);
    }
    AddRect :: (this: *ImDrawList, p_min: ImVec2, p_max: ImVec2, col: ImU32, rounding: float = 0.0, flags: ImDrawFlags = .None, thickness: float = 1.0) {
        AddRect_internal :: (this: *ImDrawList, p_min: *ImVec2, p_max: *ImVec2, col: ImU32, rounding: float, flags: ImDrawFlags, thickness: float) -> void #cpp_method #foreign imgui "?AddRect@ImDrawList@@QEAAXAEBUImVec2@@0IMHM@Z";
        AddRect_internal(this, *p_min, *p_max, col, rounding, flags, thickness);
    }
    AddRectFilled :: (this: *ImDrawList, p_min: ImVec2, p_max: ImVec2, col: ImU32, rounding: float = 0.0, flags: ImDrawFlags = .None) {
        AddRectFilled_internal :: (this: *ImDrawList, p_min: *ImVec2, p_max: *ImVec2, col: ImU32, rounding: float, flags: ImDrawFlags) -> void #cpp_method #foreign imgui "?AddRectFilled@ImDrawList@@QEAAXAEBUImVec2@@0IMH@Z";
        AddRectFilled_internal(this, *p_min, *p_max, col, rounding, flags);
    }
    AddRectFilledMultiColor :: (this: *ImDrawList, p_min: ImVec2, p_max: ImVec2, col_upr_left: ImU32, col_upr_right: ImU32, col_bot_right: ImU32, col_bot_left: ImU32) {
        AddRectFilledMultiColor_internal :: (this: *ImDrawList, p_min: *ImVec2, p_max: *ImVec2, col_upr_left: ImU32, col_upr_right: ImU32, col_bot_right: ImU32, col_bot_left: ImU32) -> void #cpp_method #foreign imgui "?AddRectFilledMultiColor@ImDrawList@@QEAAXAEBUImVec2@@0IIII@Z";
        AddRectFilledMultiColor_internal(this, *p_min, *p_max, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
    }
    AddQuad :: (this: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, p4: ImVec2, col: ImU32, thickness: float = 1.0) {
        AddQuad_internal :: (this: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, p4: *ImVec2, col: ImU32, thickness: float) -> void #cpp_method #foreign imgui "?AddQuad@ImDrawList@@QEAAXAEBUImVec2@@000IM@Z";
        AddQuad_internal(this, *p1, *p2, *p3, *p4, col, thickness);
    }
    AddQuadFilled :: (this: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, p4: ImVec2, col: ImU32) {
        AddQuadFilled_internal :: (this: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, p4: *ImVec2, col: ImU32) -> void #cpp_method #foreign imgui "?AddQuadFilled@ImDrawList@@QEAAXAEBUImVec2@@000I@Z";
        AddQuadFilled_internal(this, *p1, *p2, *p3, *p4, col);
    }
    AddTriangle :: (this: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, col: ImU32, thickness: float = 1.0) {
        AddTriangle_internal :: (this: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, col: ImU32, thickness: float) -> void #cpp_method #foreign imgui "?AddTriangle@ImDrawList@@QEAAXAEBUImVec2@@00IM@Z";
        AddTriangle_internal(this, *p1, *p2, *p3, col, thickness);
    }
    AddTriangleFilled :: (this: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, col: ImU32) {
        AddTriangleFilled_internal :: (this: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, col: ImU32) -> void #cpp_method #foreign imgui "?AddTriangleFilled@ImDrawList@@QEAAXAEBUImVec2@@00I@Z";
        AddTriangleFilled_internal(this, *p1, *p2, *p3, col);
    }
    AddCircle :: (this: *ImDrawList, center: ImVec2, radius: float, col: ImU32, num_segments: s32 = 0, thickness: float = 1.0) {
        AddCircle_internal :: (this: *ImDrawList, center: *ImVec2, radius: float, col: ImU32, num_segments: s32, thickness: float) -> void #cpp_method #foreign imgui "?AddCircle@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z";
        AddCircle_internal(this, *center, radius, col, num_segments, thickness);
    }
    AddCircleFilled :: (this: *ImDrawList, center: ImVec2, radius: float, col: ImU32, num_segments: s32 = 0) {
        AddCircleFilled_internal :: (this: *ImDrawList, center: *ImVec2, radius: float, col: ImU32, num_segments: s32) -> void #cpp_method #foreign imgui "?AddCircleFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z";
        AddCircleFilled_internal(this, *center, radius, col, num_segments);
    }
    AddNgon :: (this: *ImDrawList, center: ImVec2, radius: float, col: ImU32, num_segments: s32, thickness: float = 1.0) {
        AddNgon_internal :: (this: *ImDrawList, center: *ImVec2, radius: float, col: ImU32, num_segments: s32, thickness: float) -> void #cpp_method #foreign imgui "?AddNgon@ImDrawList@@QEAAXAEBUImVec2@@MIHM@Z";
        AddNgon_internal(this, *center, radius, col, num_segments, thickness);
    }
    AddNgonFilled :: (this: *ImDrawList, center: ImVec2, radius: float, col: ImU32, num_segments: s32) {
        AddNgonFilled_internal :: (this: *ImDrawList, center: *ImVec2, radius: float, col: ImU32, num_segments: s32) -> void #cpp_method #foreign imgui "?AddNgonFilled@ImDrawList@@QEAAXAEBUImVec2@@MIH@Z";
        AddNgonFilled_internal(this, *center, radius, col, num_segments);
    }
    AddText :: (this: *ImDrawList, pos: ImVec2, col: ImU32, text: string) {
        AddText_internal :: (this: *ImDrawList, pos: *ImVec2, col: ImU32, text_begin: *u8, text_end: *u8) -> void #cpp_method #foreign imgui "?AddText@ImDrawList@@QEAAXAEBUImVec2@@IPEBD1@Z";
        AddText_internal(this, *pos, col, text.data, text.data + text.count);
    }
    AddText :: (this: *ImDrawList, font: *ImFont, font_size: float, pos: ImVec2, col: ImU32, text: string, wrap_width: float = 0.0, cpu_fine_clip_rect: *ImVec4 = null) {
        AddText_internal :: (this: *ImDrawList, font: *ImFont, font_size: float, pos: *ImVec2, col: ImU32, text_begin: *u8, text_end: *u8, wrap_width: float, cpu_fine_clip_rect: *ImVec4) -> void #cpp_method #foreign imgui "?AddText@ImDrawList@@QEAAXPEBUImFont@@MAEBUImVec2@@IPEBD2MPEBUImVec4@@@Z";
        AddText_internal(this, font, font_size, *pos, col, text.data, text.data + text.count, wrap_width, cpu_fine_clip_rect);
    }
    AddPolyline :: (this: *ImDrawList, points: *ImVec2, num_points: s32, col: ImU32, flags: ImDrawFlags, thickness: float) -> void #cpp_method #foreign imgui "?AddPolyline@ImDrawList@@QEAAXPEBUImVec2@@HIHM@Z";
    AddConvexPolyFilled :: (this: *ImDrawList, points: *ImVec2, num_points: s32, col: ImU32) -> void #cpp_method #foreign imgui "?AddConvexPolyFilled@ImDrawList@@QEAAXPEBUImVec2@@HI@Z";
    AddBezierCubic :: (this: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, p4: ImVec2, col: ImU32, thickness: float, num_segments: s32 = 0) {
        AddBezierCubic_internal :: (this: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, p4: *ImVec2, col: ImU32, thickness: float, num_segments: s32) -> void #cpp_method #foreign imgui "?AddBezierCubic@ImDrawList@@QEAAXAEBUImVec2@@000IMH@Z";
        AddBezierCubic_internal(this, *p1, *p2, *p3, *p4, col, thickness, num_segments);
    }
    AddBezierQuadratic :: (this: *ImDrawList, p1: ImVec2, p2: ImVec2, p3: ImVec2, col: ImU32, thickness: float, num_segments: s32 = 0) {
        AddBezierQuadratic_internal :: (this: *ImDrawList, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, col: ImU32, thickness: float, num_segments: s32) -> void #cpp_method #foreign imgui "?AddBezierQuadratic@ImDrawList@@QEAAXAEBUImVec2@@00IMH@Z";
        AddBezierQuadratic_internal(this, *p1, *p2, *p3, col, thickness, num_segments);
    }
    AddImage :: (this: *ImDrawList, user_texture_id: ImTextureID, p_min: ImVec2, p_max: ImVec2, uv_min: ImVec2 = ImVec2.{0,0}, uv_max: ImVec2 = ImVec2.{1,1}, col: ImU32 = 4294967295) {
        AddImage_internal :: (this: *ImDrawList, user_texture_id: ImTextureID, p_min: *ImVec2, p_max: *ImVec2, uv_min: *ImVec2, uv_max: *ImVec2, col: ImU32) -> void #cpp_method #foreign imgui "?AddImage@ImDrawList@@QEAAXPEAXAEBUImVec2@@111I@Z";
        AddImage_internal(this, user_texture_id, *p_min, *p_max, *uv_min, *uv_max, col);
    }
    AddImageQuad :: (this: *ImDrawList, user_texture_id: ImTextureID, p1: ImVec2, p2: ImVec2, p3: ImVec2, p4: ImVec2, uv1: ImVec2 = ImVec2.{0,0}, uv2: ImVec2 = ImVec2.{1,0}, uv3: ImVec2 = ImVec2.{1,1}, uv4: ImVec2 = ImVec2.{0,1}, col: ImU32 = 4294967295) {
        AddImageQuad_internal :: (this: *ImDrawList, user_texture_id: ImTextureID, p1: *ImVec2, p2: *ImVec2, p3: *ImVec2, p4: *ImVec2, uv1: *ImVec2, uv2: *ImVec2, uv3: *ImVec2, uv4: *ImVec2, col: ImU32) -> void #cpp_method #foreign imgui "?AddImageQuad@ImDrawList@@QEAAXPEAXAEBUImVec2@@1111111I@Z";
        AddImageQuad_internal(this, user_texture_id, *p1, *p2, *p3, *p4, *uv1, *uv2, *uv3, *uv4, col);
    }
    AddImageRounded :: (this: *ImDrawList, user_texture_id: ImTextureID, p_min: ImVec2, p_max: ImVec2, uv_min: ImVec2, uv_max: ImVec2, col: ImU32, rounding: float, flags: ImDrawFlags = .None) {
        AddImageRounded_internal :: (this: *ImDrawList, user_texture_id: ImTextureID, p_min: *ImVec2, p_max: *ImVec2, uv_min: *ImVec2, uv_max: *ImVec2, col: ImU32, rounding: float, flags: ImDrawFlags) -> void #cpp_method #foreign imgui "?AddImageRounded@ImDrawList@@QEAAXPEAXAEBUImVec2@@111IMH@Z";
        AddImageRounded_internal(this, user_texture_id, *p_min, *p_max, *uv_min, *uv_max, col, rounding, flags);
    }
    /* (jaicc: omitted inline function)
    PathClear :: (this: *ImDrawList) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    PathLineTo :: (this: *ImDrawList, pos: ImVec2) {
        PathLineTo_internal :: (this: *ImDrawList, pos: *ImVec2) -> void #cpp_method {
        }
        PathLineTo_internal(this, *pos);
    }
    */

    /* (jaicc: omitted inline function)
    PathLineToMergeDuplicate :: (this: *ImDrawList, pos: ImVec2) {
        PathLineToMergeDuplicate_internal :: (this: *ImDrawList, pos: *ImVec2) -> void #cpp_method {
        }
        PathLineToMergeDuplicate_internal(this, *pos);
    }
    */

    /* (jaicc: omitted inline function)
    PathFillConvex :: (this: *ImDrawList, col: ImU32) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    PathStroke :: (this: *ImDrawList, col: ImU32, flags: ImDrawFlags = .None, thickness: float = 1.0) -> void #cpp_method {
    }
    */

    PathArcTo :: (this: *ImDrawList, center: ImVec2, radius: float, a_min: float, a_max: float, num_segments: s32 = 0) {
        PathArcTo_internal :: (this: *ImDrawList, center: *ImVec2, radius: float, a_min: float, a_max: float, num_segments: s32) -> void #cpp_method #foreign imgui "?PathArcTo@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z";
        PathArcTo_internal(this, *center, radius, a_min, a_max, num_segments);
    }
    PathArcToFast :: (this: *ImDrawList, center: ImVec2, radius: float, a_min_of_12: s32, a_max_of_12: s32) {
        PathArcToFast_internal :: (this: *ImDrawList, center: *ImVec2, radius: float, a_min_of_12: s32, a_max_of_12: s32) -> void #cpp_method #foreign imgui "?PathArcToFast@ImDrawList@@QEAAXAEBUImVec2@@MHH@Z";
        PathArcToFast_internal(this, *center, radius, a_min_of_12, a_max_of_12);
    }
    PathBezierCubicCurveTo :: (this: *ImDrawList, p2: ImVec2, p3: ImVec2, p4: ImVec2, num_segments: s32 = 0) {
        PathBezierCubicCurveTo_internal :: (this: *ImDrawList, p2: *ImVec2, p3: *ImVec2, p4: *ImVec2, num_segments: s32) -> void #cpp_method #foreign imgui "?PathBezierCubicCurveTo@ImDrawList@@QEAAXAEBUImVec2@@00H@Z";
        PathBezierCubicCurveTo_internal(this, *p2, *p3, *p4, num_segments);
    }
    PathBezierQuadraticCurveTo :: (this: *ImDrawList, p2: ImVec2, p3: ImVec2, num_segments: s32 = 0) {
        PathBezierQuadraticCurveTo_internal :: (this: *ImDrawList, p2: *ImVec2, p3: *ImVec2, num_segments: s32) -> void #cpp_method #foreign imgui "?PathBezierQuadraticCurveTo@ImDrawList@@QEAAXAEBUImVec2@@0H@Z";
        PathBezierQuadraticCurveTo_internal(this, *p2, *p3, num_segments);
    }
    PathRect :: (this: *ImDrawList, rect_min: ImVec2, rect_max: ImVec2, rounding: float = 0.0, flags: ImDrawFlags = .None) {
        PathRect_internal :: (this: *ImDrawList, rect_min: *ImVec2, rect_max: *ImVec2, rounding: float, flags: ImDrawFlags) -> void #cpp_method #foreign imgui "?PathRect@ImDrawList@@QEAAXAEBUImVec2@@0MH@Z";
        PathRect_internal(this, *rect_min, *rect_max, rounding, flags);
    }
    AddCallback :: (this: *ImDrawList, callback: ImDrawCallback, callback_data: *void) -> void #cpp_method #foreign imgui "?AddCallback@ImDrawList@@QEAAXP6AXPEBU1@PEBUImDrawCmd@@@ZPEAX@Z";
    AddDrawCmd :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?AddDrawCmd@ImDrawList@@QEAAXXZ";
    CloneOutput :: (this: *ImDrawList) -> *ImDrawList #cpp_method #foreign imgui "?CloneOutput@ImDrawList@@QEBAPEAU1@XZ";
    /* (jaicc: omitted inline function)
    ChannelsSplit :: (this: *ImDrawList, count: s32) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    ChannelsMerge :: (this: *ImDrawList) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    ChannelsSetCurrent :: (this: *ImDrawList, n: s32) -> void #cpp_method {
    }
    */

    PrimReserve :: (this: *ImDrawList, idx_count: s32, vtx_count: s32) -> void #cpp_method #foreign imgui "?PrimReserve@ImDrawList@@QEAAXHH@Z";
    PrimUnreserve :: (this: *ImDrawList, idx_count: s32, vtx_count: s32) -> void #cpp_method #foreign imgui "?PrimUnreserve@ImDrawList@@QEAAXHH@Z";
    PrimRect :: (this: *ImDrawList, a: ImVec2, b: ImVec2, col: ImU32) {
        PrimRect_internal :: (this: *ImDrawList, a: *ImVec2, b: *ImVec2, col: ImU32) -> void #cpp_method #foreign imgui "?PrimRect@ImDrawList@@QEAAXAEBUImVec2@@0I@Z";
        PrimRect_internal(this, *a, *b, col);
    }
    PrimRectUV :: (this: *ImDrawList, a: ImVec2, b: ImVec2, uv_a: ImVec2, uv_b: ImVec2, col: ImU32) {
        PrimRectUV_internal :: (this: *ImDrawList, a: *ImVec2, b: *ImVec2, uv_a: *ImVec2, uv_b: *ImVec2, col: ImU32) -> void #cpp_method #foreign imgui "?PrimRectUV@ImDrawList@@QEAAXAEBUImVec2@@000I@Z";
        PrimRectUV_internal(this, *a, *b, *uv_a, *uv_b, col);
    }
    PrimQuadUV :: (this: *ImDrawList, a: ImVec2, b: ImVec2, c: ImVec2, d: ImVec2, uv_a: ImVec2, uv_b: ImVec2, uv_c: ImVec2, uv_d: ImVec2, col: ImU32) {
        PrimQuadUV_internal :: (this: *ImDrawList, a: *ImVec2, b: *ImVec2, c: *ImVec2, d: *ImVec2, uv_a: *ImVec2, uv_b: *ImVec2, uv_c: *ImVec2, uv_d: *ImVec2, col: ImU32) -> void #cpp_method #foreign imgui "?PrimQuadUV@ImDrawList@@QEAAXAEBUImVec2@@0000000I@Z";
        PrimQuadUV_internal(this, *a, *b, *c, *d, *uv_a, *uv_b, *uv_c, *uv_d, col);
    }
    /* (jaicc: omitted inline function)
    PrimWriteVtx :: (this: *ImDrawList, pos: ImVec2, uv: ImVec2, col: ImU32) {
        PrimWriteVtx_internal :: (this: *ImDrawList, pos: *ImVec2, uv: *ImVec2, col: ImU32) -> void #cpp_method {
        }
        PrimWriteVtx_internal(this, *pos, *uv, col);
    }
    */

    /* (jaicc: omitted inline function)
    PrimWriteIdx :: (this: *ImDrawList, idx: ImDrawIdx) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    PrimVtx :: (this: *ImDrawList, pos: ImVec2, uv: ImVec2, col: ImU32) {
        PrimVtx_internal :: (this: *ImDrawList, pos: *ImVec2, uv: *ImVec2, col: ImU32) -> void #cpp_method {
        }
        PrimVtx_internal(this, *pos, *uv, col);
    }
    */

    _ResetForNewFrame :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?_ResetForNewFrame@ImDrawList@@QEAAXXZ";
    _ClearFreeMemory :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?_ClearFreeMemory@ImDrawList@@QEAAXXZ";
    _PopUnusedDrawCmd :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?_PopUnusedDrawCmd@ImDrawList@@QEAAXXZ";
    _TryMergeDrawCmds :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?_TryMergeDrawCmds@ImDrawList@@QEAAXXZ";
    _OnChangedClipRect :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?_OnChangedClipRect@ImDrawList@@QEAAXXZ";
    _OnChangedTextureID :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?_OnChangedTextureID@ImDrawList@@QEAAXXZ";
    _OnChangedVtxOffset :: (this: *ImDrawList) -> void #cpp_method #foreign imgui "?_OnChangedVtxOffset@ImDrawList@@QEAAXXZ";
    _CalcCircleAutoSegmentCount :: (this: *ImDrawList, radius: float) -> s32 #cpp_method #foreign imgui "?_CalcCircleAutoSegmentCount@ImDrawList@@QEBAHM@Z";
    _PathArcToFastEx :: (this: *ImDrawList, center: ImVec2, radius: float, a_min_sample: s32, a_max_sample: s32, a_step: s32) {
        _PathArcToFastEx_internal :: (this: *ImDrawList, center: *ImVec2, radius: float, a_min_sample: s32, a_max_sample: s32, a_step: s32) -> void #cpp_method #foreign imgui "?_PathArcToFastEx@ImDrawList@@QEAAXAEBUImVec2@@MHHH@Z";
        _PathArcToFastEx_internal(this, *center, radius, a_min_sample, a_max_sample, a_step);
    }
    _PathArcToN :: (this: *ImDrawList, center: ImVec2, radius: float, a_min: float, a_max: float, num_segments: s32) {
        _PathArcToN_internal :: (this: *ImDrawList, center: *ImVec2, radius: float, a_min: float, a_max: float, num_segments: s32) -> void #cpp_method #foreign imgui "?_PathArcToN@ImDrawList@@QEAAXAEBUImVec2@@MMMH@Z";
        _PathArcToN_internal(this, *center, radius, a_min, a_max, num_segments);
    }
}
// #run check_size(ImDrawList, 200);

ImDrawData :: struct {
    Valid: bool;
    CmdListsCount: s32;
    TotalIdxCount: s32;
    TotalVtxCount: s32;
    CmdLists: **ImDrawList;
    DisplayPos: ImVec2;
    DisplaySize: ImVec2;
    FramebufferScale: ImVec2;
    OwnerViewport: *Viewport;
    /* (jaicc: omitted inline function)
    Clear :: (this: *ImDrawData) -> void #cpp_method {
    }
    */

    DeIndexAllBuffers :: (this: *ImDrawData) -> void #cpp_method #foreign imgui "?DeIndexAllBuffers@ImDrawData@@QEAAXXZ";
    ScaleClipRects :: (this: *ImDrawData, fb_scale: ImVec2) {
        ScaleClipRects_internal :: (this: *ImDrawData, fb_scale: *ImVec2) -> void #cpp_method #foreign imgui "?ScaleClipRects@ImDrawData@@QEAAXAEBUImVec2@@@Z";
        ScaleClipRects_internal(this, *fb_scale);
    }
}
// #run check_size(ImDrawData, 56);

ImFontConfig :: struct {
    FontData: *void;
    FontDataSize: s32;
    FontDataOwnedByAtlas: bool;
    FontNo: s32;
    SizePixels: float;
    OversampleH: s32;
    OversampleV: s32;
    PixelSnapH: bool;
    GlyphExtraSpacing: ImVec2;
    GlyphOffset: ImVec2;
    GlyphRanges: *ImWchar;
    GlyphMinAdvanceX: float;
    GlyphMaxAdvanceX: float;
    MergeMode: bool;
    FontBuilderFlags: u32;
    RasterizerMultiply: float;
    EllipsisChar: ImWchar;
    Name: [40] u8;
    DstFont: *ImFont;
}
// #run check_size(ImFontConfig, 136);

ImFontGlyph :: struct {
    Colored: u32;
    #place Colored; /*bitfield 1*/     Visible: u32;
    #place Colored; /*bitfield 2*/     Codepoint: u32;
    AdvanceX: float;
    X0: float;
    Y0: float;
    X1: float;
    Y1: float;
    U0: float;
    V0: float;
    U1: float;
    V1: float;
}
// #run check_size(ImFontGlyph, 40);

ImFontGlyphRangesBuilder :: struct {
    UsedChars: ImVector(ImU32);
    /* (jaicc: omitted inline function)
    Clear :: (this: *ImFontGlyphRangesBuilder) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    GetBit :: (this: *ImFontGlyphRangesBuilder, n: size_t) -> bool #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    SetBit :: (this: *ImFontGlyphRangesBuilder, n: size_t) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    AddChar :: (this: *ImFontGlyphRangesBuilder, c: ImWchar) -> void #cpp_method {
    }
    */

    AddText :: (this: *ImFontGlyphRangesBuilder, text: string) {
        AddText_internal :: (this: *ImFontGlyphRangesBuilder, text: *u8, text_end: *u8) -> void #cpp_method #foreign imgui "?AddText@ImFontGlyphRangesBuilder@@QEAAXPEBD0@Z";
        AddText_internal(this, text.data, text.data + text.count);
    }
    AddRanges :: (this: *ImFontGlyphRangesBuilder, ranges: *ImWchar) -> void #cpp_method #foreign imgui "?AddRanges@ImFontGlyphRangesBuilder@@QEAAXPEBG@Z";
    BuildRanges :: (this: *ImFontGlyphRangesBuilder, out_ranges: **ImVector(u16)) -> void #cpp_method #foreign imgui "?BuildRanges@ImFontGlyphRangesBuilder@@QEAAXPEAU?$ImVector@G@@@Z";
}
// #run check_size(ImFontGlyphRangesBuilder, 16);

ImFontAtlasCustomRect :: struct {
    Width: u16;
    Height: u16;
    X: u16;
    Y: u16;
    GlyphID: u32;
    GlyphAdvanceX: float;
    GlyphOffset: ImVec2;
    Font: *ImFont;
    /* (jaicc: omitted inline function)
    IsPacked :: (this: *ImFontAtlasCustomRect) -> bool #cpp_method {
    }
    */

}
// #run check_size(ImFontAtlasCustomRect, 32);

ImFontAtlasFlags :: enum s32 {
    None :: 0;
    NoPowerOfTwoHeight :: 1;
    NoMouseCursors :: 2;
    NoBakedLines :: 4;
}

ImFontAtlas :: struct {
    /* (jaicc: function missing foreign lib)
    Destructor :: (this: *ImFontAtlas) -> void #cpp_method #foreign __UnknownLib "??_DImFontAtlas@@QEAAXXZ";
    */

    AddFont :: (this: *ImFontAtlas, font_cfg: *ImFontConfig) -> *ImFont #cpp_method #foreign imgui "?AddFont@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z";
    AddFontDefault :: (this: *ImFontAtlas, font_cfg: *ImFontConfig = null) -> *ImFont #cpp_method #foreign imgui "?AddFontDefault@ImFontAtlas@@QEAAPEAUImFont@@PEBUImFontConfig@@@Z";
    AddFontFromFileTTF :: (this: *ImFontAtlas, filename: *u8, size_pixels: float, font_cfg: *ImFontConfig = null, glyph_ranges: *ImWchar = null) -> *ImFont #cpp_method #foreign imgui "?AddFontFromFileTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z";
    AddFontFromMemoryTTF :: (this: *ImFontAtlas, font_data: *void, font_size: s32, size_pixels: float, font_cfg: *ImFontConfig = null, glyph_ranges: *ImWchar = null) -> *ImFont #cpp_method #foreign imgui "?AddFontFromMemoryTTF@ImFontAtlas@@QEAAPEAUImFont@@PEAXHMPEBUImFontConfig@@PEBG@Z";
    AddFontFromMemoryCompressedTTF :: (this: *ImFontAtlas, compressed_font_data: *void, compressed_font_size: s32, size_pixels: float, font_cfg: *ImFontConfig = null, glyph_ranges: *ImWchar = null) -> *ImFont #cpp_method #foreign imgui "?AddFontFromMemoryCompressedTTF@ImFontAtlas@@QEAAPEAUImFont@@PEBXHMPEBUImFontConfig@@PEBG@Z";
    AddFontFromMemoryCompressedBase85TTF :: (this: *ImFontAtlas, compressed_font_data_base85: *u8, size_pixels: float, font_cfg: *ImFontConfig = null, glyph_ranges: *ImWchar = null) -> *ImFont #cpp_method #foreign imgui "?AddFontFromMemoryCompressedBase85TTF@ImFontAtlas@@QEAAPEAUImFont@@PEBDMPEBUImFontConfig@@PEBG@Z";
    ClearInputData :: (this: *ImFontAtlas) -> void #cpp_method #foreign imgui "?ClearInputData@ImFontAtlas@@QEAAXXZ";
    ClearTexData :: (this: *ImFontAtlas) -> void #cpp_method #foreign imgui "?ClearTexData@ImFontAtlas@@QEAAXXZ";
    ClearFonts :: (this: *ImFontAtlas) -> void #cpp_method #foreign imgui "?ClearFonts@ImFontAtlas@@QEAAXXZ";
    Clear :: (this: *ImFontAtlas) -> void #cpp_method #foreign imgui "?Clear@ImFontAtlas@@QEAAXXZ";
    Build :: (this: *ImFontAtlas) -> bool #cpp_method #foreign imgui "?Build@ImFontAtlas@@QEAA_NXZ";
    GetTexDataAsAlpha8 :: (this: *ImFontAtlas, out_pixels: **u8, out_width: *s32, out_height: *s32, out_bytes_per_pixel: *s32 = null) -> void #cpp_method #foreign imgui "?GetTexDataAsAlpha8@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z";
    GetTexDataAsRGBA32 :: (this: *ImFontAtlas, out_pixels: **u8, out_width: *s32, out_height: *s32, out_bytes_per_pixel: *s32 = null) -> void #cpp_method #foreign imgui "?GetTexDataAsRGBA32@ImFontAtlas@@QEAAXPEAPEAEPEAH11@Z";
    /* (jaicc: omitted inline function)
    IsBuilt :: (this: *ImFontAtlas) -> bool #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    SetTexID :: (this: *ImFontAtlas, id: ImTextureID) -> void #cpp_method {
    }
    */

    GetGlyphRangesDefault :: (this: *ImFontAtlas) -> *ImWchar #cpp_method #foreign imgui "?GetGlyphRangesDefault@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesKorean :: (this: *ImFontAtlas) -> *ImWchar #cpp_method #foreign imgui "?GetGlyphRangesKorean@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesJapanese :: (this: *ImFontAtlas) -> *ImWchar #cpp_method #foreign imgui "?GetGlyphRangesJapanese@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesChineseFull :: (this: *ImFontAtlas) -> *ImWchar #cpp_method #foreign imgui "?GetGlyphRangesChineseFull@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesChineseSimplifiedCommon :: (this: *ImFontAtlas) -> *ImWchar #cpp_method #foreign imgui "?GetGlyphRangesChineseSimplifiedCommon@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesCyrillic :: (this: *ImFontAtlas) -> *ImWchar #cpp_method #foreign imgui "?GetGlyphRangesCyrillic@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesThai :: (this: *ImFontAtlas) -> *ImWchar #cpp_method #foreign imgui "?GetGlyphRangesThai@ImFontAtlas@@QEAAPEBGXZ";
    GetGlyphRangesVietnamese :: (this: *ImFontAtlas) -> *ImWchar #cpp_method #foreign imgui "?GetGlyphRangesVietnamese@ImFontAtlas@@QEAAPEBGXZ";
    AddCustomRectRegular :: (this: *ImFontAtlas, width: s32, height: s32) -> s32 #cpp_method #foreign imgui "?AddCustomRectRegular@ImFontAtlas@@QEAAHHH@Z";
    AddCustomRectFontGlyph :: (this: *ImFontAtlas, font: *ImFont, id: ImWchar, width: s32, height: s32, advance_x: float, offset: ImVec2 = ImVec2.{0,0}) -> s32 {
        AddCustomRectFontGlyph_internal :: (this: *ImFontAtlas, font: *ImFont, id: ImWchar, width: s32, height: s32, advance_x: float, offset: *ImVec2) -> s32 #cpp_method #foreign imgui "?AddCustomRectFontGlyph@ImFontAtlas@@QEAAHPEAUImFont@@GHHMAEBUImVec2@@@Z";
        return AddCustomRectFontGlyph_internal(this, font, id, width, height, advance_x, *offset);
    }
    /* (jaicc: omitted inline function)
    GetCustomRectByIndex :: (this: *ImFontAtlas, index: s32) -> *ImFontAtlasCustomRect #cpp_method {
    }
    */

    CalcCustomRectUV :: (this: *ImFontAtlas, rect: *ImFontAtlasCustomRect, out_uv_min: *ImVec2, out_uv_max: *ImVec2) -> void #cpp_method #foreign imgui "?CalcCustomRectUV@ImFontAtlas@@QEBAXPEBUImFontAtlasCustomRect@@PEAUImVec2@@1@Z";
    GetMouseCursorTexData :: (this: *ImFontAtlas, cursor: MouseCursor, out_offset: *ImVec2, out_size: *ImVec2, out_uv_border: *[2] ImVec2, out_uv_fill: *[2] ImVec2) -> bool #cpp_method #foreign imgui "?GetMouseCursorTexData@ImFontAtlas@@QEAA_NHPEAUImVec2@@0QEAU2@1@Z";
    Flags: ImFontAtlasFlags;
    TexID: ImTextureID;
    TexDesiredWidth: s32;
    TexGlyphPadding: s32;
    Locked: bool;
    TexPixelsUseColors: bool;
    TexPixelsAlpha8: *u8;
    TexPixelsRGBA32: *u32;
    TexWidth: s32;
    TexHeight: s32;
    TexUvScale: ImVec2;
    TexUvWhitePixel: ImVec2;
    Fonts: ImVector(*ImFont);
    CustomRects: ImVector(ImFontAtlasCustomRect);
    ConfigData: ImVector(ImFontConfig);
    TexUvLines: [64] ImVec4;
    FontBuilderIO: *ImFontBuilderIO;
    FontBuilderFlags: u32;
    PackIdMouseCursors: s32;
    PackIdLines: s32;
}
// #run check_size(ImFontAtlas, 1168);

ImFont :: struct {
    IndexAdvanceX: ImVector(float);
    FallbackAdvanceX: float;
    FontSize: float;
    IndexLookup: ImVector(u16);
    Glyphs: ImVector(ImFontGlyph);
    FallbackGlyph: *ImFontGlyph;
    ContainerAtlas: *ImFontAtlas;
    ConfigData: *ImFontConfig;
    ConfigDataCount: s16;
    FallbackChar: ImWchar;
    EllipsisChar: ImWchar;
    DotChar: ImWchar;
    DirtyLookupTables: bool;
    Scale: float;
    Ascent: float;
    Descent: float;
    MetricsTotalSurface: s32;
    Used4kPagesMap: [2] ImU8;
    /* (jaicc: function missing foreign lib)
    Destructor :: (this: *ImFont) -> void #cpp_method #foreign __UnknownLib "??_DImFont@@QEAAXXZ";
    */

    FindGlyph :: (this: *ImFont, c: ImWchar) -> *ImFontGlyph #cpp_method #foreign imgui "?FindGlyph@ImFont@@QEBAPEBUImFontGlyph@@G@Z";
    FindGlyphNoFallback :: (this: *ImFont, c: ImWchar) -> *ImFontGlyph #cpp_method #foreign imgui "?FindGlyphNoFallback@ImFont@@QEBAPEBUImFontGlyph@@G@Z";
    /* (jaicc: omitted inline function)
    GetCharAdvance :: (this: *ImFont, c: ImWchar) -> float #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    IsLoaded :: (this: *ImFont) -> bool #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    GetDebugName :: (this: *ImFont) -> *u8 #cpp_method {
    }
    */

    CalcTextSizeA :: (this: *ImFont, size: float, max_width: float, wrap_width: float, text: string, remaining: **u8 = null) -> ImVec2 {
        CalcTextSizeA_internal :: (this: *ImFont, size: float, max_width: float, wrap_width: float, text_begin: *u8, text_end: *u8, remaining: **u8) -> ImVec2 #cpp_method #foreign imgui "?CalcTextSizeA@ImFont@@QEBA?AUImVec2@@MMMPEBD0PEAPEBD@Z";
        return CalcTextSizeA_internal(this, size, max_width, wrap_width, text.data, text.data + text.count, remaining);
    }
    CalcWordWrapPositionA :: (this: *ImFont, scale: float, text: string, wrap_width: float) -> *u8 {
        CalcWordWrapPositionA_internal :: (this: *ImFont, scale: float, text: *u8, text_end: *u8, wrap_width: float) -> *u8 #cpp_method #foreign imgui "?CalcWordWrapPositionA@ImFont@@QEBAPEBDMPEBD0M@Z";
        return CalcWordWrapPositionA_internal(this, scale, text.data, text.data + text.count, wrap_width);
    }
    RenderChar :: (this: *ImFont, draw_list: *ImDrawList, size: float, pos: ImVec2, col: ImU32, c: ImWchar) -> void #cpp_method #foreign imgui "?RenderChar@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IG@Z";
    RenderText :: (this: *ImFont, draw_list: *ImDrawList, size: float, pos: ImVec2, col: ImU32, clip_rect: ImVec4, text: string, wrap_width: float = 0.0, cpu_fine_clip: bool = false) {
        RenderText_internal :: (this: *ImFont, draw_list: *ImDrawList, size: float, pos: ImVec2, col: ImU32, clip_rect: *ImVec4, text_begin: *u8, text_end: *u8, wrap_width: float, cpu_fine_clip: bool) -> void #cpp_method #foreign imgui "?RenderText@ImFont@@QEBAXPEAUImDrawList@@MUImVec2@@IAEBUImVec4@@PEBD3M_N@Z";
        RenderText_internal(this, draw_list, size, pos, col, *clip_rect, text.data, text.data + text.count, wrap_width, cpu_fine_clip);
    }
    BuildLookupTable :: (this: *ImFont) -> void #cpp_method #foreign imgui "?BuildLookupTable@ImFont@@QEAAXXZ";
    ClearOutputData :: (this: *ImFont) -> void #cpp_method #foreign imgui "?ClearOutputData@ImFont@@QEAAXXZ";
    GrowIndex :: (this: *ImFont, new_size: s32) -> void #cpp_method #foreign imgui "?GrowIndex@ImFont@@QEAAXH@Z";
    AddGlyph :: (this: *ImFont, src_cfg: *ImFontConfig, c: ImWchar, x0: float, y0: float, x1: float, y1: float, u0: float, v0: float, u1: float, v1: float, advance_x: float) -> void #cpp_method #foreign imgui "?AddGlyph@ImFont@@QEAAXPEBUImFontConfig@@GMMMMMMMMM@Z";
    AddRemapChar :: (this: *ImFont, dst: ImWchar, src: ImWchar, overwrite_dst: bool = true) -> void #cpp_method #foreign imgui "?AddRemapChar@ImFont@@QEAAXGG_N@Z";
    SetGlyphVisible :: (this: *ImFont, c: ImWchar, visible: bool) -> void #cpp_method #foreign imgui "?SetGlyphVisible@ImFont@@QEAAXG_N@Z";
    IsGlyphRangeUnused :: (this: *ImFont, c_begin: u32, c_last: u32) -> bool #cpp_method #foreign imgui "?IsGlyphRangeUnused@ImFont@@QEAA_NII@Z";
}
// #run check_size(ImFont, 112);

ViewportFlags :: enum s32 {
    None :: 0;
    IsPlatformWindow :: 1;
    IsPlatformMonitor :: 2;
    OwnedByApp :: 4;
    NoDecoration :: 8;
    NoTaskBarIcon :: 16;
    NoFocusOnAppearing :: 32;
    NoFocusOnClick :: 64;
    NoInputs :: 128;
    NoRendererClear :: 256;
    TopMost :: 512;
    Minimized :: 1024;
    NoAutoMerge :: 2048;
    CanHostOtherWindows :: 4096;
}

Viewport :: struct {
    ID_: ID;
    Flags: ViewportFlags;
    Pos: ImVec2;
    Size: ImVec2;
    WorkPos: ImVec2;
    WorkSize: ImVec2;
    DpiScale: float;
    ParentViewportId: ID;
    DrawData: *ImDrawData;
    RendererUserData: *void;
    PlatformUserData: *void;
    PlatformHandle: *void;
    PlatformHandleRaw: *void;
    PlatformRequestMove: bool;
    PlatformRequestResize: bool;
    PlatformRequestClose: bool;
    /* (jaicc: omitted inline function)
    Destructor :: (this: *Viewport) -> void #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    GetCenter :: (this: *Viewport) -> ImVec2 #cpp_method {
    }
    */

    /* (jaicc: omitted inline function)
    GetWorkCenter :: (this: *Viewport) -> ImVec2 #cpp_method {
    }
    */

}
// #run check_size(Viewport, 96);

PlatformIO :: struct {
    Platform_CreateWindow: #type (a0: *Viewport) -> void #c_call;
    Platform_DestroyWindow: #type (a0: *Viewport) -> void #c_call;
    Platform_ShowWindow: #type (a0: *Viewport) -> void #c_call;
    Platform_SetWindowPos: #type (a0: *Viewport, a1: ImVec2) -> void #c_call;
    Platform_GetWindowPos: #type (a0: *Viewport) -> ImVec2 #c_call;
    Platform_SetWindowSize: #type (a0: *Viewport, a1: ImVec2) -> void #c_call;
    Platform_GetWindowSize: #type (a0: *Viewport) -> ImVec2 #c_call;
    Platform_SetWindowFocus: #type (a0: *Viewport) -> void #c_call;
    Platform_GetWindowFocus: #type (a0: *Viewport) -> bool #c_call;
    Platform_GetWindowMinimized: #type (a0: *Viewport) -> bool #c_call;
    Platform_SetWindowTitle: #type (a0: *Viewport, a1: *u8) -> void #c_call;
    Platform_SetWindowAlpha: #type (a0: *Viewport, a1: float) -> void #c_call;
    Platform_UpdateWindow: #type (a0: *Viewport) -> void #c_call;
    Platform_RenderWindow: #type (a0: *Viewport, a1: *void) -> void #c_call;
    Platform_SwapBuffers: #type (a0: *Viewport, a1: *void) -> void #c_call;
    Platform_GetWindowDpiScale: #type (a0: *Viewport) -> float #c_call;
    Platform_OnChangedViewport: #type (a0: *Viewport) -> void #c_call;
    Platform_SetImeInputPos: #type (a0: *Viewport, a1: ImVec2) -> void #c_call;
    Platform_CreateVkSurface: #type (a0: *Viewport, a1: ImU64, a2: *void, a3: *ImU64) -> s32 #c_call;
    Renderer_CreateWindow: #type (a0: *Viewport) -> void #c_call;
    Renderer_DestroyWindow: #type (a0: *Viewport) -> void #c_call;
    Renderer_SetWindowSize: #type (a0: *Viewport, a1: ImVec2) -> void #c_call;
    Renderer_RenderWindow: #type (a0: *Viewport, a1: *void) -> void #c_call;
    Renderer_SwapBuffers: #type (a0: *Viewport, a1: *void) -> void #c_call;
    Monitors: ImVector(PlatformMonitor);
    Viewports: ImVector(*Viewport);
}
// #run check_size(PlatformIO, 224);

PlatformMonitor :: struct {
    MainPos: ImVec2;
    MainSize: ImVec2;
    WorkPos: ImVec2;
    WorkSize: ImVec2;
    DpiScale: float;
}
// #run check_size(PlatformMonitor, 36);

Preprocessor_Defines :: struct {
    USE_BGRA_PACKED_COLOR: bool : true;
}

