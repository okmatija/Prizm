// Copyright Epic Games, Inc. All Rights Reserved.

Command_Info :: struct {
    name : string;
    usage : string;
    procedure : ([]Any) -> (); // This will be the *_boiler_plate procedure generated by the meta-program
}

Console :: struct {
    history : [..]string; // different to log in that command feedback is not stored in the history
    history_position : int = -1; // -1: new line, 0..history.count-1 browsing history
    commands : [..]Command_Info;
    log : [..]string;
    input_buffer : [256]u8;
}

console_logger :: (message: string, data: *void, info: Log_Info) {
    console_log := cast(*[..]string) data;
    if info.common_flags & .ERROR {
        array_add(console_log, join("[error] ", message));
        app.show_console_ui = true;
    } else if info.common_flags & .WARNING {
        array_add(console_log, join("[warning] ", message));
    } else {
        array_add(console_log, copy_string(message));
    }
}

console_clear_log :: () {
    for app.console.log free(it);
    array_reset(*app.console.log);
}

console_add_history :: (format_string: string, args: .. Any) {
    builder: String_Builder;
    defer free_buffers(*builder);

    print_to_builder(*builder, format_string, ..args);

    text := builder_to_string(*builder);

    // Insert into history. First find match and delete it so it can be pushed to the back.
    for app.console.history {
        if equal_nocase(text, it) {
            remove it;
            break;
        }
    }
    array_add(*app.console.history, text);
} @PrintLike

console_clear_history :: () {
    for app.console.history free(it);
    array_reset(*app.console.history);
}

console_execute_command :: (_command : string) {
    app.console.history_position = -1;

    p : Parser;
    p.data = _command;
    p.tokens = get_tokens("console command", p.data);
    p.current_token = 0;

    if !p.tokens.count return;

    assert(p.tokens[p.tokens.count-1].type == .EOF);

    // Creates an Any in temporary storage so that we can return an Any created from a value on the stack, and have the value_pointer be valid after the stack unrolls
    copy_any :: (x: Any) -> Any {
        any: Any = ---;
        any.type = x.type;
        any.value_pointer = temporary_alloc(x.type.runtime_size);
        memcpy(any.value_pointer, x.value_pointer, x.type.runtime_size);
        return any;
    }

    // @TODO Allow nested function calls?
    command_name : string;
    command_args : [..]Any;
    // @Refactor Not a good way of handling signed numbers!!!!
    // @Incomplete issue error when strings are negated etc
    sign := 1;
    while !p.failed {
        tok := peek_token(*p);
        if tok.type == .EOF {
            break;
        } else if tok.type == .IDENTIFIER {
            if sign < 0 {
                p.failed = true;
                log_error("Unexpected preceeding - token.");
                console_add_history("%", _command);
                return;
            } else if command_name != "" {
                log_error("Unexpected token IDENTIFIER (%) in argument list, string arguments use single/double quotes.", to_string(tok));
                console_add_history("%", _command);
                return;
            }
            command_name = tok.string_value;
            eat_token(*p);
        } else if tok.type == .SQSTRING || tok.type == .DQSTRING {
            if sign < 0 {
                p.failed = true;
                log_error("Unexpected preceeding - token.");
                console_add_history("%", _command);
                return;
            }
            array_add(*command_args, copy_any(tok.string_value));
            eat_token(*p);
        } else if tok.type == xx #char "-" {
            sign = -1;
            eat_token(*p);
        } else if tok.type == .INTEGER {
            // @TODO Consider adding entity type with literal #NNN
            array_add(*command_args, copy_any(sign * tok.integer_value));
            sign = 1;
            eat_token(*p);
        } else if tok.type == .FLOAT {
            array_add(*command_args, copy_any(sign * tok.float_value));
            sign = 1;
            eat_token(*p);
        } else {
            // @Cleanup Use parser.jai error function with custom logger which prints to the console
            p.failed = true;
            log_error("Unexpected token %.", to_string(tok));
            console_add_history("%", _command);
            return;
        }
    }

    if p.failed {
        return;
    }

    found_command := false;
    for app.console.commands {
        if it.name == command_name {

            console_add_history("%", _command);
            log("%", _command);
            it.procedure(command_args);

            found_command = true;
            break;
        }
    }

    if command_name != "" && !found_command {
        log_error("'%' : Command not found", command_name);
    }
}

console_draw :: () {
    if !app.show_console_ui return;

    console_top_y := app.current_window_height * .6;
    ImGui.SetNextWindowPos(make_ImVec2(0, xx console_top_y));
    ImGui.SetNextWindowSize(make_ImVec2(xx app.current_window_width, xx (app.current_window_height - console_top_y)), .Always);
    ImGui.Begin("console", flags = ImGui.WindowFlags.AlwaysAutoResize | ImGui.WindowFlags.NoTitleBar); // TODO if !Begin should close

    ImGui.TextWrapped("Enter 'help' for help, press TAB for text completion, press UP/DOWN to navigate history.");

    // ImGui.SameLine();
    // if (ImGui.SmallButton("Clear")) {
    //      console_clear_log();
    // }
    ImGui.Separator();

    footer_height_to_reserve := ImGui.GetStyle().ItemSpacing.y + ImGui.GetFrameHeightWithSpacing(); // 1 separator, 1 input text

    scrolling_region_size : ImGui.ImVec2;
    scrolling_region_size.x = -footer_height_to_reserve;
    scrolling_region_size.y = -footer_height_to_reserve;
    ImGui.BeginChild("ScrollingRegion", scrolling_region_size, false, .HorizontalScrollbar); // Leave room for 1 separator + 1 InputText
    if (ImGui.BeginPopupContextWindow()) {
        if ImGui.Selectable("Clear") {
            console_clear_log();
        }
        ImGui.EndPopup();
    }

    ImGui.PushStyleVar(.ItemSpacing, ImGui.ImVec2.{4,1}); // Tighten spacing
    for item : app.console.log {
        assert(item.count != 0);
        col := ImGui.ImVec4.{1., 1., 1., 1.};
        if begins_with(item, "#") {
            col = ImGui.ImVec4.{1., .78, .58, 1.};
        } else if begins_with(item, "[warning]") {
            col = ImGui.ImVec4.{0., .78, .58, 1.};
        } else if begins_with(item, "[error]") {
            col = ImGui.ImVec4.{1., .4, .4, 1.};
        }
        ImGui.TextColored(col, "%", item);
    }
    ImGui.PopStyleVar();
    ImGui.EndChild();
    ImGui.Separator();

    {
        using ImGui.InputTextFlags; // @Question this using is here due to: "Operator '|' does not work on this type. (Left type of the attempted binary operation: unary '.' dereference; right type: unary '.' dereference)"

        // console passed as user data but it's a global so...
        // if (ImGui.InputText("", console.input_buffer.data, console.input_buffer.count, EnterReturnsTrue | AlwaysInsertMode)) {

        ImGui.PushItemWidth(-1);
        text_input_flags :=  ImGui.InputTextFlags.EnterReturnsTrue | .CallbackCompletion | .CallbackHistory;
        if (ImGui.InputText("", app.console.input_buffer.data, app.console.input_buffer.count, text_input_flags, text_edit_callback, *app.console)) {
            defer app.console.input_buffer[0] = 0; // Wipe input after processing
            console_execute_command(to_string(app.console.input_buffer.data, c_style_strlen(app.console.input_buffer.data)));
        }
        ImGui.PopItemWidth();

        // Keeping auto focus on the input box after command is entered
        if (ImGui.IsItemHovered() || ( ImGui.IsWindowFocused(.RootAndChildWindows) &&
                                      !ImGui.IsAnyItemActive()                     &&
                                      !ImGui.IsMouseClicked(0))) {
            ImGui.SetKeyboardFocusHere(-1); // Auto focus previous widget
        }
    }


    ImGui.End();
}

#scope_file

print_location :: (loc := #caller_location) {
    print("%:%\n", loc.fully_pathed_filename, loc.line_number);
}

text_edit_callback :: (data : *ImGui.InputTextCallbackData) -> s32 #c_call {

    new_context : Context;
    new_context.logger = console_logger;
    new_context.logger_data = *app.console.log;
    push_context new_context {

        // @Cleanup Why does this fail? app is global so I expected we could pass null and just read it directly.
        // assert(cast(*void) data == cast(*void) *app.console);

        if data.EventFlag == {
            case .CallbackCompletion; {

                // Only complete the function name
                current_input := to_string(data.Buf, data.CursorPos);
                if contains(current_input, " ") {
                    return 0;
                }

                // Locate beginning of current word
                word_end := data.Buf + data.CursorPos;
                word_start := word_end;
                while word_start > data.Buf {
                    c := <<(word_start - 1);
                    if (c == #char " " || c == #char "\t" || c == #char "," || c == #char ";")
                        break;
                    word_start -= 1;
                }

                current_word := to_string(word_start, word_end - word_start);

                // @CompilerBug: Even though we have pushed a context we get an error about calling a native procedure
                // printv(#code current_word);
                // print("current_word = %\n", current_word);

                // Build a list of candidates // @TODO Use temporary allocator here
                candidates : [..]string;
                candidates_usage : [..]string;
                for app.console.commands {
                    if begins_with_nocase(it.name, current_word) {
                        array_add(*candidates, it.name);
                        array_add(*candidates_usage, it.usage);
                    }
                }

                if candidates.count == 0 {
                    // No match
                } else if candidates.count == 1 {
                    // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing
                    data.DeleteChars(data, xx (word_start - data.Buf), xx (word_end - word_start));
                    data.InsertChars(data, data.CursorPos, candidates[0]);
                    data.InsertChars(data, data.CursorPos, " ");

                    // List matches
                    console_clear_log();
                    log("# Matching commands:");
                    for candidate : candidates_usage {
                        log("#  %", candidate);
                    }
                } else {
                    // Multiple matches. Complete as much as we can

                    cursor : s32 = xx (word_end - word_start);
                    while true {

                        cursor_character : u8;
                        all_candidates_match := true;
                        for candidate, candidate_index : candidates {
                            if !all_candidates_match {
                                break;
                            }

                            if cursor == candidate.count {
                                all_candidates_match = false;
                            } else if candidate_index == 0 {
                                cursor_character = to_upper(candidates[0][cursor]);
                            } else if cursor_character != to_upper(candidate[cursor]) {
                                all_candidates_match = false;
                            }
                        }

                        if !all_candidates_match {
                            break;
                        }

                        cursor += 1;
                    }

                    if cursor > 0 {
                        data.DeleteChars(data, xx (word_start - data.Buf), xx (word_end - word_start));
                        tmp := slice(candidates[0], 0, cursor);
                        data.InsertChars(data, data.CursorPos, tmp);
                    }

                    // List matches
                    console_clear_log();
                    log("# Matching commands:");
                    for candidate : candidates_usage {
                        log("#  %", candidate);
                    }
                }
            }

            case .CallbackHistory; {

                using app;

                prev_history_position := console.history_position;
                if data.EventKey == .UpArrow {
                    if console.history_position == -1 {
                        console.history_position = console.history.count - 1;
                    } else if console.history_position > 0 {
                        console.history_position -= 1;
                    }
                } else if data.EventKey == .DownArrow {
                    if console.history_position != -1 {
                        console.history_position += 1;
                        if console.history_position >= console.history.count {
                            console.history_position = -1;
                        }
                    }
                }

                // A better implementation would preserve the data on the current input line along with cursor position.
                if prev_history_position != console.history_position {

                    if console.history_position >= 0 {
                        item := console.history[console.history_position];
                        data.CursorPos = xx item.count;
                        memcpy(data.Buf, item.data, item.count);
                        data.Buf[item.count] = 0;
                        data.BufTextLen = xx item.count;
                    } else {
                        data.CursorPos = 0;
                        data.Buf[0] = 0;
                        data.BufTextLen = 0;
                    }

                    assert(c_style_strlen(data.Buf) == data.BufTextLen);

                    data.SelectionStart = data.CursorPos;
                    data.SelectionEnd = data.CursorPos;
                    data.BufDirty = true;
                }
            }
        }
    }

    return 0;
}

#scope_file

make_ImVec2 :: inline (a: float, b: float) -> ImGui.ImVec2 {
    v: ImGui.ImVec2 = ---;
    v.x = a;
    v.y = b;
    return v;
}