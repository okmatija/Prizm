Command_Info :: struct {
    name : string;
    usage : string;
    documentation : string;
    procedure : ([]Any) -> (); // This will be the *_boiler_plate procedure generated by the meta-program
}

Console :: struct {
    history : [..]string; // Different to log in that command feedback is not stored in the history
    history_position : int = -1; // -1: new line, 0..history.count-1 browsing history
    commands : [..]Command_Info;
    log : [..]string;
    input_buffer : [256]u8;

    Log_Mode :: enum {
        INTERACTIVE;
        TRANSPARENT;
    }

    visible := false;
    log_mode := Log_Mode.TRANSPARENT;
    scroll_to_bottom := true;
    scroll_to_bottom_frame_count := SCROLL_TO_BOTTOM_FRAME_INIT;
}

console_logger :: (message: string, data: *void, info: Log_Info) {
    console_log := cast(*[..]string) data;
    if info.common_flags & .ERROR {
        array_add(console_log, join("[error] ", message));
        app.console.visible = true;
    } else if info.common_flags & .WARNING {
        array_add(console_log, join("[warning] ", message));
    } else {
        array_add(console_log, copy_string(message));
    }
    if app.console.scroll_to_bottom {
        app.console.scroll_to_bottom_frame_count = SCROLL_TO_BOTTOM_FRAME_INIT;
    }
}

// Clear all the text shown in the console
console_log_clear :: () {
    for app.console.log free(it);
    array_reset(*app.console.log);
} @RegisterCommand

console_add_history :: (format_string: string, args: .. Any) {
    builder: String_Builder;
    defer free_buffers(*builder);

    print_to_builder(*builder, format_string, ..args);

    text := builder_to_string(*builder);

    // Insert into history. First find match and delete it so it can be pushed to the back.
    for app.console.history {
        if equal_nocase(text, it) {
            remove it;
            break;
        }
    }
    array_add(*app.console.history, text);
} @PrintLike

console_save_history :: () {
    history_string : string;
    for app.console.history {
        history_string = join(history_string, it, "\n"); // @Leak
    }
    write_entire_file("console_history.txt", history_string);
}

console_load_history :: () {
    console_history_file, ok := read_entire_file("console_history.txt", zero_terminated=true);
    if ok {
        file_lines := split(console_history_file, "\n");
        for file_lines {
            if trim(it, " ") != "" {
                console_add_history(it);
            }
        }
    } else {
        // log("Could not load console history from 'console_history.txt' file");
    }
}

// Clear the history of console commands
console_history_clear :: () {
    for app.console.history free(it);
    array_reset(*app.console.history);
    console_save_history();
} @RegisterCommand

console_execute_command :: (_command : string) {
    app.console.history_position = -1;
    defer console_save_history();

    p : Parser;
    p.data = _command;
    p.tokens = get_tokens("console command", p.data);
    p.current_token = 0;

    if !p.tokens.count return;

    assert(p.tokens[p.tokens.count-1].type == .EOF);

    // Creates an Any in temporary storage so that we can return an Any created from a value on the stack, and have the value_pointer be valid after the stack unrolls
    copy_any :: (x: Any) -> Any {
        any: Any = ---;
        any.type = x.type;
        any.value_pointer = temporary_alloc(x.type.runtime_size);
        memcpy(any.value_pointer, x.value_pointer, x.type.runtime_size);
        return any;
    }

    // @TODO Allow nested function calls?
    command_name : string;
    command_args : [..]Any;
    while !p.failed {
        tok := peek_token(*p);
        if tok.type == .EOF {
            break;
        } else if tok.type == .IDENTIFIER {
            if command_name != "" {
                log_error("Unexpected token IDENTIFIER (%) in argument list, string arguments use single/double quotes.", to_string(tok));
                console_add_history("%", _command);
                return;
            }
            command_name = tok.string_value;
            eat_token(*p);
        } else if tok.type == .SQSTRING || tok.type == .DQSTRING {
            array_add(*command_args, copy_any(tok.string_value));
            eat_token(*p);
        } else if tok.type == .INTEGER {
            // @TODO Consider adding entity type with literal #NNN
            array_add(*command_args, copy_any(tok.integer_value));
            eat_token(*p);
        } else if tok.type == .FLOAT {
            array_add(*command_args, copy_any(tok.float_value));
            eat_token(*p);
        } else {
            // @Cleanup Use parser.jai error function with custom logger which prints to the console
            p.failed = true;
            log_error("Unexpected token %.", to_string(tok));
            console_add_history("%", _command);
            return;
        }
    }

    if p.failed {
        return;
    }

    found_command := false;
    for app.console.commands {
        if it.name == command_name {

            console_add_history("%", _command);
            log("%", _command);
            it.procedure(command_args);

            found_command = true;
            break;
        }
    }

    if command_name != "" && !found_command {
        log_error("'%' : Command not found", command_name);
    }
}

console_draw :: () {
    if app.console.visible == false return;

    window_pivot := make_ImVec2(0, 1); // SetNextWindowPos will refer to the bottom left corner of the window
    input_window_height : float = -1;
    scroll_delta_request : float;

    // Draw input window
    {
        console_top_y := app.current_window_height * .6;
        ImGui.SetNextWindowPos(make_ImVec2(0, xx app.current_window_height), pivot=window_pivot);
        ImGui.SetNextWindowSize(make_ImVec2(xx app.current_window_width, -1), .Always);

        window_flags := ImGui.WindowFlags.NoTitleBar | .NoResize | .NoDecoration;
        ImGui.Begin("console_input", flags=window_flags); // TODO if !Begin should close
        defer ImGui.End();

        ImGui.PushItemWidth(-65); // Set to leave space for UI to the right of the text input @Cleanup This is a bit crappy
        text_input_flags :=  ImGui.InputTextFlags.EnterReturnsTrue | .CallbackCompletion | .CallbackHistory;
        reclaim_focus := ImGui.IsWindowAppearing();
        if (ImGui.InputText("", app.console.input_buffer.data, app.console.input_buffer.count, text_input_flags, text_edit_callback, *app.console)) {
            defer app.console.input_buffer[0] = 0; // Wipe input after processing
            buffer := to_string(app.console.input_buffer.data, c_style_strlen(app.console.input_buffer.data));
            console_execute_command(buffer);
            reclaim_focus = true;
        }
        ImGui.PopItemWidth();

        // @Refactor Make this type of tooltip a reusable function
        if ImGui.IsItemHovered() {
            ImGui.BeginTooltip();
            ImGui.BeginTable("", 3, flags=ImGui.TableFlags.NoBordersInBody);

            ImGui.TableNextRow(); ImGui.TableNextColumn();
            ImGui.TextColored(KEYBINDING_COLOR, "TAB");
            ImGui.TableNextColumn();
            ImGui.Text("List commands and show command documentation");

            // ImGui.TableNextRow(); ImGui.TableNextColumn();
            // ImGui.TextColored(KEYBINDING_COLOR, "ESC/`");
            // ImGui.TableNextColumn();
            // ImGui.Text("Hide/toggle console");

            ImGui.TableNextRow(); ImGui.TableNextColumn();
            ImGui.TextColored(KEYBINDING_COLOR, "UP/DOWN");
            ImGui.TableNextColumn();
            ImGui.Text("Navigate command history");

            ImGui.TableNextRow(); ImGui.TableNextColumn();
            ImGui.TextColored(KEYBINDING_COLOR, "Scroll");
            ImGui.TableNextColumn();
            ImGui.Text("Scroll the console log");

            ImGui.EndTable();
            ImGui.EndTooltip();

            // Negative so scrolling works as it does when hovering the scrollable region when the using INTERACTIVE mode
            scroll_delta_request = -30 * io().MouseWheel;
        }

        // Keeping auto focus on the input box after command is entered
        if reclaim_focus {
            ImGui.SetKeyboardFocusHere(-1); // Auto focus previous widget
        }

        ImGui.SameLine();

        if ImGui.Button("Options") {
            ImGui.OpenPopup("console_options");
        }

        if ImGui.BeginPopup("console_options") {
            is_interactive := app.console.log_mode == .INTERACTIVE;
            if ImGui.Checkbox("Interactive Log", *is_interactive) {
                app.console.log_mode = ifx is_interactive then Console.Log_Mode.INTERACTIVE else .TRANSPARENT;
                ImGui.CloseCurrentPopup();
            }
            if ImGui.Checkbox("Scroll to bottom", *app.console.scroll_to_bottom) {
                ImGui.CloseCurrentPopup();
            }
            if ImGui.Button("Save to LOG.txt") {
                contents : string;
                defer free(contents);
                contents = join(contents, "This console log was saved via a button in the Prism application\n");
                contents = join(contents, "Press '`' to open the console and find the button in the Options menu\n\n\n\n");
                for app.console.log {
                    contents = join(contents, it, separator="\n");
                }
                write_entire_file_to_cwd("LOG.txt", contents);
            }
            Show_Tooltip("Write the console log to LOG.txt\nHandy if you want to search the console log");
            ImGui.EndPopup();
        }

        input_window_height = ImGui.GetWindowHeight();
    }

    // Draw output window
    // @Incomplete Make the text selectable in INTERACTIVE mode
    if app.console.log.count != 0 {

        window_flags := ImGui.WindowFlags.NoTitleBar | .NoResize | .NoDecoration;
        if app.console.log_mode == .TRANSPARENT {
            window_flags |= .NoBringToFrontOnFocus; // Prioritize drawing item list if it covers the console
            window_flags |= .NoInputs;              // So we can interact with the scene behind the console output window
            window_flags |= .NoFocusOnAppearing;    // So we dont clobber the reclaim_focus stuff in the console input window
            window_flags |= .NoBackground;          // Makes the console log transparent
        }

        // The + 20 is just a bit extra that we need, + 1 because... well, something is fishy
        console_height := min(ImGui.GetFontSize() * (app.console.log.count + 1) + 20, app.current_window_height * .4);
        ImGui.SetNextWindowPos(make_ImVec2(0, xx (app.current_window_height - input_window_height)), pivot=window_pivot);
        ImGui.SetNextWindowSize(make_ImVec2(xx app.current_window_width, xx console_height), .Always);

        ImGui.Begin("console_output", flags=window_flags); // TODO if !Begin should close
        scrolling_region_flags := ImGui.WindowFlags.HorizontalScrollbar;
        if app.console.log_mode == .TRANSPARENT {
            scrolling_region_flags |= .NoInputs;   // So we can interact with the scene behind the console output window
            scrolling_region_flags |= .NoScrollbar; // Save some screenspace since we wont be interacting with the console log anyway
        }

        ImGui.BeginChild("ScrollingRegion", border=false, flags=scrolling_region_flags);
        ImGui.PushStyleVar(.ItemSpacing, ImGui.ImVec2.{4,1}); // Tighten spacing
        for item : app.console.log {
            assert(item.count != 0);
            col := ifx app.console.log_mode == .INTERACTIVE then CONSOLE_INFO_INTERACTIVE else CONSOLE_INFO_TRANSPARENT;
            if begins_with(item, "#") {
                col = ifx app.console.log_mode == .INTERACTIVE then CONSOLE_COMMENT_INTERACTIVE else CONSOLE_COMMENT_TRANSPARENT;
            } else if begins_with(item, "|") {
                col = ifx app.console.log_mode == .INTERACTIVE then CONSOLE_DOCUMENTATION_INTERACTIVE else CONSOLE_DOCUMENTATION_TRANSPARENT;
            } else if begins_with(item, "[warning]") {
                col = ifx app.console.log_mode == .INTERACTIVE then CONSOLE_WARNING_INTERACTIVE else CONSOLE_WARNING_TRANSPARENT;
            } else if begins_with(item, "[error]") {
                col = ifx app.console.log_mode == .INTERACTIVE then CONSOLE_ERROR_INTERACTIVE else CONSOLE_ERROR_TRANSPARENT;
            }
            ImGui.TextColored(col, "%", item);
        }
        ImGui.PopStyleVar();

        if app.console.scroll_to_bottom_frame_count != 0 {
            ImGui.SetScrollY(ImGui.GetScrollMaxY());
            app.console.scroll_to_bottom_frame_count -= 1;
        }

        if scroll_delta_request != 0 {
            ImGui.SetScrollY(ImGui.GetScrollY() + scroll_delta_request);
        }

        ImGui.EndChild();

        ImGui.End();
    }
}

#scope_file

print_location :: (loc := #caller_location) {
    print("%:%\n", loc.fully_pathed_filename, loc.line_number);
}

text_edit_callback :: (data : *ImGui.InputTextCallbackData) -> s32 #c_call {

    new_context : Context;
    new_context.logger = console_logger;
    new_context.logger_data = *app.console.log;
    push_context new_context {

        // We pass *app.console as user data but use it directly since its global... whatever
        assert(cast(*void) data.UserData == cast(*void) *app.console);

        if data.EventFlag == {
            case .CallbackCompletion; {

                // Only complete the function name
                current_input := to_string(data.Buf, data.CursorPos);
                if contains(trim(current_input), " ") {
                    return 0;
                }

                // Locate beginning of current word
                word_end := data.Buf + data.CursorPos;
                word_start := data.Buf + trim_right(current_input, " ").count;
                while word_start > data.Buf {
                    c := <<(word_start - 1);
                    if (c == #char " " || c == #char "\t" || c == #char "," || c == #char ";")
                        break;
                    word_start -= 1;
                }

                current_word := to_string(word_start, word_end - word_start);
                // print("current_word = '%'\n", current_word);

                // Build a list of candidates
                candidates : [..]Command_Info;
                candidates.allocator = temp;
                for app.console.commands {
                    if begins_with_nocase(it.name, current_word) {
                        array_add(*candidates, it);
                    } else if it.name == trim_right(current_word) {
                        // Handles case when current_word has trailing spaces
                        array_add(*candidates, it);
                    }
                }

                if candidates.count == 0 {
                    // No match
                    console_log_clear();
                    log("# 0 matching commands");

                } else if candidates.count == 1 {
                    // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing
                    data.DeleteChars(data, xx (word_start - data.Buf), xx (word_end - word_start));
                    data.InsertChars(data, data.CursorPos, candidates[0].name);
                    data.InsertChars(data, data.CursorPos, " ");

                    // List matches
                    console_log_clear();
                    for candidate : candidates {
                        doc_lines := split(candidate.documentation, "\n");
                        for line : doc_lines log("%", line);
                    }
                } else {
                    // Multiple matches. Complete as much as we can

                    cursor : s32 = xx (word_end - word_start);
                    while true {

                        cursor_character : u8;
                        all_candidates_match := true;
                        for candidate, candidate_index : candidates {
                            if all_candidates_match == false {
                                break;
                            }

                            if cursor == candidate.name.count {
                                all_candidates_match = false;
                            } else if candidate_index == 0 {
                                cursor_character = to_upper(candidates[0].name[cursor]);
                            } else if cursor_character != to_upper(candidate.name[cursor]) {
                                all_candidates_match = false;
                            }
                        }

                        if !all_candidates_match {
                            break;
                        }

                        cursor += 1;
                    }

                    if cursor > 0 {
                        data.DeleteChars(data, xx (word_start - data.Buf), xx (word_end - word_start));
                        tmp := slice(candidates[0].name, 0, cursor);
                        data.InsertChars(data, data.CursorPos, tmp);
                    }

                    // List matches
                    console_log_clear();
                    log("# % matching commands:", candidates.count);
                    for candidate : candidates{
                        log("#  %", candidate.usage);
                    }
                }
            }

            case .CallbackHistory; {

                prev_history_position := app.console.history_position;
                if data.EventKey == .UpArrow {
                    if app.console.history_position == -1 {
                        app.console.history_position = app.console.history.count - 1;
                    } else if app.console.history_position > 0 {
                        app.console.history_position -= 1;
                    }
                } else if data.EventKey == .DownArrow {
                    if app.console.history_position != -1 {
                        app.console.history_position += 1;
                        if app.console.history_position >= app.console.history.count {
                            app.console.history_position = -1;
                        }
                    }
                }

                // A better implementation would preserve the data on the current input line along with cursor position.
                if prev_history_position != app.console.history_position {

                    if app.console.history_position >= 0 {
                        item := app.console.history[app.console.history_position];
                        data.CursorPos = xx item.count;
                        memcpy(data.Buf, item.data, item.count);
                        data.Buf[item.count] = 0;
                        data.BufTextLen = xx item.count;
                    } else {
                        data.CursorPos = 0;
                        data.Buf[0] = 0;
                        data.BufTextLen = 0;
                    }

                    assert(c_style_strlen(data.Buf) == data.BufTextLen);

                    data.SelectionStart = data.CursorPos;
                    data.SelectionEnd = data.CursorPos;
                    data.BufDirty = true;
                }
            }
        }
    }

    return 0;
}

#scope_file

make_ImVec2 :: inline (a: float, b: float) -> ImGui.ImVec2 {
    v: ImGui.ImVec2 = ---;
    v.x = a;
    v.y = b;
    return v;
}

// ImGui.SetScrollY needs to be called in two consecutive frames to scroll to the bottom of the console
// perhaps this isn't needed, or is a bug in ImGui? @Cleanup
SCROLL_TO_BOTTOM_FRAME_INIT :: 2;
