Command_Info :: struct {
    name : string;
    usage : string;
    documentation : string;
    procedure : ([]Any) -> (); // This will be the *_boiler_plate procedure generated by the meta-program
}

Console :: struct {
    visible := false;
    opaque := false;
    history : [..]string; // Different to log in that command feedback is not stored in the history
    history_position : int = -1; // -1: new line, 0..history.count-1 browsing history
    commands : [..]Command_Info;
    log : [..]string;
    input_buffer : [256]u8;
}

console_logger :: (message: string, data: *void, info: Log_Info) {
    console_log := cast(*[..]string) data;
    if info.common_flags & .ERROR {
        array_add(console_log, join("[error] ", message));
        app.console.visible = true;
    } else if info.common_flags & .WARNING {
        array_add(console_log, join("[warning] ", message));
    } else {
        array_add(console_log, copy_string(message));
    }
}

// Clear all the text shown in the console
console_clear_log :: () {
    for app.console.log free(it);
    array_reset(*app.console.log);
} @RegisterCommand

console_add_history :: (format_string: string, args: .. Any) {
    builder: String_Builder;
    defer free_buffers(*builder);

    print_to_builder(*builder, format_string, ..args);

    text := builder_to_string(*builder);

    // Insert into history. First find match and delete it so it can be pushed to the back.
    for app.console.history {
        if equal_nocase(text, it) {
            remove it;
            break;
        }
    }
    array_add(*app.console.history, text);
} @PrintLike

console_save_history :: () {
    history_string : string;
    for app.console.history {
        history_string = join(history_string, it, "\n"); // @Leak
    }
    write_entire_file("console_history.txt", history_string);
}

console_load_history :: () {
    console_history_file, ok := read_entire_file("console_history.txt", zero_terminated=true);
    if ok {
        file_lines := split(console_history_file, "\n");
        for file_lines {
            if trim(it, " ") != "" {
                console_add_history(it);
            }
        }
    } else {
        // log("Could not load console history from 'console_history.txt' file");
    }
}

// Clear the history of console commands
console_clear_history :: () {
    for app.console.history free(it);
    array_reset(*app.console.history);
    console_save_history();
} @RegisterCommand

console_execute_command :: (_command : string) {
    app.console.history_position = -1;
    defer console_save_history();

    p : Parser;
    p.data = _command;
    p.tokens = get_tokens("console command", p.data);
    p.current_token = 0;

    if !p.tokens.count return;

    assert(p.tokens[p.tokens.count-1].type == .EOF);

    // Creates an Any in temporary storage so that we can return an Any created from a value on the stack, and have the value_pointer be valid after the stack unrolls
    copy_any :: (x: Any) -> Any {
        any: Any = ---;
        any.type = x.type;
        any.value_pointer = temporary_alloc(x.type.runtime_size);
        memcpy(any.value_pointer, x.value_pointer, x.type.runtime_size);
        return any;
    }

    // @TODO Allow nested function calls?
    command_name : string;
    command_args : [..]Any;
    while !p.failed {
        tok := peek_token(*p);
        if tok.type == .EOF {
            break;
        } else if tok.type == .IDENTIFIER {
            if command_name != "" {
                log_error("Unexpected token IDENTIFIER (%) in argument list, string arguments use single/double quotes.", to_string(tok));
                console_add_history("%", _command);
                return;
            }
            command_name = tok.string_value;
            eat_token(*p);
        } else if tok.type == .SQSTRING || tok.type == .DQSTRING {
            array_add(*command_args, copy_any(tok.string_value));
            eat_token(*p);
        } else if tok.type == .INTEGER {
            // @TODO Consider adding entity type with literal #NNN
            array_add(*command_args, copy_any(tok.integer_value));
            eat_token(*p);
        } else if tok.type == .FLOAT {
            array_add(*command_args, copy_any(tok.float_value));
            eat_token(*p);
        } else {
            // @Cleanup Use parser.jai error function with custom logger which prints to the console
            p.failed = true;
            log_error("Unexpected token %.", to_string(tok));
            console_add_history("%", _command);
            return;
        }
    }

    if p.failed {
        return;
    }

    found_command := false;
    for app.console.commands {
        if it.name == command_name {

            console_add_history("%", _command);
            log("%", _command);
            it.procedure(command_args);

            found_command = true;
            break;
        }
    }

    if command_name != "" && !found_command {
        log_error("'%' : Command not found", command_name);
    }
}

console_draw :: () {
    if app.console.visible == false return;

    window_flags := ImGui.WindowFlags.NoTitleBar | .NoResize | .NoDecoration;
    if app.console.opaque == false window_flags |= .NoBackground;

    window_pivot := make_ImVec2(0, 1); // SetNextWindowPos will refer to the bottom left corner of the window
    input_window_height : float = -1;

    // Draw input window
    {
        console_top_y := app.current_window_height * .6;
        ImGui.SetNextWindowPos(make_ImVec2(0, xx app.current_window_height), pivot=window_pivot);
        ImGui.SetNextWindowSize(make_ImVec2(xx app.current_window_width, -1), .Always);

        ImGui.Begin("console_input", flags=window_flags); // TODO if !Begin should close
        defer ImGui.End();

        ImGui.PushItemWidth(-115); // Set to leave space for UI to the right of the text input @Cleanup This is a bit crappy
        text_input_flags :=  ImGui.InputTextFlags.EnterReturnsTrue | .CallbackCompletion | .CallbackHistory;
        reclaim_focus := ImGui.IsWindowAppearing();
        if (ImGui.InputText("", app.console.input_buffer.data, app.console.input_buffer.count, text_input_flags, text_edit_callback, *app.console)) {
            defer app.console.input_buffer[0] = 0; // Wipe input after processing
            buffer := to_string(app.console.input_buffer.data, c_style_strlen(app.console.input_buffer.data));
            console_execute_command(buffer);
            reclaim_focus = true;
        }
        ImGui.PopItemWidth();

        // @Refactor Make this type of tooltip a reusable function
        if (ImGui.IsItemHovered()) {
            ImGui.BeginTooltip();
            ImGui.BeginTable("", 3, flags=ImGui.TableFlags.NoBordersInBody);

            ImGui.TableNextRow(); ImGui.TableNextColumn();
            ImGui.TextColored(KEYBINDING_COLOR, "TAB");
            ImGui.TableNextColumn();
            ImGui.Text("List commands and show command documentation");

            ImGui.TableNextRow(); ImGui.TableNextColumn();
            ImGui.TextColored(KEYBINDING_COLOR, "ESC/`");
            ImGui.TableNextColumn();
            ImGui.Text("Hide/toggle console");

            ImGui.TableNextRow(); ImGui.TableNextColumn();
            ImGui.TextColored(KEYBINDING_COLOR, "UP/DOWN");
            ImGui.TableNextColumn();
            ImGui.Text("Navigate command history");

            ImGui.EndTable();
            ImGui.EndTooltip();
        }

        // Keeping auto focus on the input box after command is entered
        if reclaim_focus {
            ImGui.SetKeyboardFocusHere(-1); // Auto focus previous widget
        }

        ImGui.SameLine();
        ImGui.ColorEdit4("##comment", *app.debug_console_color.component, ImGui.ColorEditFlags.NoInputs);
        Show_Tooltip("Info");
        ImGui.SameLine();
        ImGui.ColorEdit4("##warning", *app.debug_console_color.component, ImGui.ColorEditFlags.NoInputs);
        Show_Tooltip("Warning");
        ImGui.SameLine();
        ImGui.ColorEdit4("##error", *app.debug_console_color.component, ImGui.ColorEditFlags.NoInputs);
        Show_Tooltip("Warning");

        ImGui.SameLine();
        if ImGui.Button("Tgl Console Bg") {
            app.console.opaque = !app.console.opaque;
        }

        input_window_height = ImGui.GetWindowHeight();
    }

    // Draw output window
    // @Think Maybe we want the text selectable in the opaque view?
    {
        window_flags |= .NoInputs;              // So we can interact with the scene behind the console output window
        window_flags |= .NoFocusOnAppearing;    // So we dont clobber the reclaim_focus stuff in the console input window
        window_flags |= .NoBringToFrontOnFocus; // Prioritize drawing item list if it covers the console
        if app.console.opaque == false {
            window_flags |= .NoBackground;
        }

        console_top_y := app.current_window_height * .6;
        ImGui.SetNextWindowPos(make_ImVec2(0, xx (app.current_window_height - input_window_height)), pivot=window_pivot);
        ImGui.SetNextWindowSize(make_ImVec2(xx app.current_window_width, xx (app.current_window_height - console_top_y)), .Always);

        ImGui.Begin("console_output", flags=window_flags); // TODO if !Begin should close
        defer ImGui.End();

        ImGui.BeginChild("ScrollingRegion", border=false, flags=ImGui.WindowFlags.HorizontalScrollbar| .NoScrollbar | .NoInputs);
        defer ImGui.EndChild();

        ImGui.PushStyleVar(.ItemSpacing, ImGui.ImVec2.{4,1}); // Tighten spacing
        defer ImGui.PopStyleVar();

        for item : app.console.log {
            assert(item.count != 0);
            col := app.debug_console_color;// ifx app.console.opaque then CONSOLE_INFO_OPAQUE else CONSOLE_INFO;
            if begins_with(item, "#") {
                col = ifx app.console.opaque then CONSOLE_COMMENT_OPAQUE else CONSOLE_COMMENT;
            } else if begins_with(item, "[warning]") {
                col = ifx app.console.opaque then CONSOLE_WARNING_OPAQUE else CONSOLE_WARNING;
            } else if begins_with(item, "[error]") {
                col = ifx app.console.opaque then CONSOLE_ERROR_OPAQUE else CONSOLE_ERROR;
            }
            ImGui.TextColored(col, "%", item);
        }
    }
}

#scope_file

print_location :: (loc := #caller_location) {
    print("%:%\n", loc.fully_pathed_filename, loc.line_number);
}

text_edit_callback :: (data : *ImGui.InputTextCallbackData) -> s32 #c_call {

    new_context : Context;
    new_context.logger = console_logger;
    new_context.logger_data = *app.console.log;
    push_context new_context {

        // We pass *app.console as user data but use it directly since its global... whatever
        assert(cast(*void) data.UserData == cast(*void) *app.console);

        if data.EventFlag == {
            case .CallbackCompletion; {

                // Only complete the function name
                current_input := to_string(data.Buf, data.CursorPos);
                if contains(trim(current_input), " ") {
                    return 0;
                }

                // Locate beginning of current word
                word_end := data.Buf + data.CursorPos;
                word_start := data.Buf + trim_right(current_input, " ").count;
                while word_start > data.Buf {
                    c := <<(word_start - 1);
                    if (c == #char " " || c == #char "\t" || c == #char "," || c == #char ";")
                        break;
                    word_start -= 1;
                }

                current_word := to_string(word_start, word_end - word_start);
                // print("current_word = '%'\n", current_word);

                // Build a list of candidates
                candidates : [..]Command_Info;
                candidates.allocator = temp;
                for app.console.commands {
                    if begins_with_nocase(it.name, current_word) {
                        array_add(*candidates, it);
                    } else if it.name == trim_right(current_word) {
                        // Handles case when current_word has trailing spaces
                        array_add(*candidates, it);
                    }
                }

                if candidates.count == 0 {
                    // No match
                    console_clear_log();
                    log("# 0 matching commands");

                } else if candidates.count == 1 {
                    // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing
                    data.DeleteChars(data, xx (word_start - data.Buf), xx (word_end - word_start));
                    data.InsertChars(data, data.CursorPos, candidates[0].name);
                    data.InsertChars(data, data.CursorPos, " ");

                    // List matches
                    console_clear_log();
                    for candidate : candidates {
                        log("#  %", candidate.documentation);
                    }
                } else {
                    // Multiple matches. Complete as much as we can

                    cursor : s32 = xx (word_end - word_start);
                    while true {

                        cursor_character : u8;
                        all_candidates_match := true;
                        for candidate, candidate_index : candidates {
                            if all_candidates_match == false {
                                break;
                            }

                            if cursor == candidate.name.count {
                                all_candidates_match = false;
                            } else if candidate_index == 0 {
                                cursor_character = to_upper(candidates[0].name[cursor]);
                            } else if cursor_character != to_upper(candidate.name[cursor]) {
                                all_candidates_match = false;
                            }
                        }

                        if !all_candidates_match {
                            break;
                        }

                        cursor += 1;
                    }

                    if cursor > 0 {
                        data.DeleteChars(data, xx (word_start - data.Buf), xx (word_end - word_start));
                        tmp := slice(candidates[0].name, 0, cursor);
                        data.InsertChars(data, data.CursorPos, tmp);
                    }

                    // List matches
                    console_clear_log();
                    log("# % matching commands:", candidates.count);
                    for candidate : candidates{
                        log("#  %", candidate.usage);
                    }
                }
            }

            case .CallbackHistory; {

                prev_history_position := app.console.history_position;
                if data.EventKey == .UpArrow {
                    if app.console.history_position == -1 {
                        app.console.history_position = app.console.history.count - 1;
                    } else if app.console.history_position > 0 {
                        app.console.history_position -= 1;
                    }
                } else if data.EventKey == .DownArrow {
                    if app.console.history_position != -1 {
                        app.console.history_position += 1;
                        if app.console.history_position >= app.console.history.count {
                            app.console.history_position = -1;
                        }
                    }
                }

                // A better implementation would preserve the data on the current input line along with cursor position.
                if prev_history_position != app.console.history_position {

                    if app.console.history_position >= 0 {
                        item := app.console.history[app.console.history_position];
                        data.CursorPos = xx item.count;
                        memcpy(data.Buf, item.data, item.count);
                        data.Buf[item.count] = 0;
                        data.BufTextLen = xx item.count;
                    } else {
                        data.CursorPos = 0;
                        data.Buf[0] = 0;
                        data.BufTextLen = 0;
                    }

                    assert(c_style_strlen(data.Buf) == data.BufTextLen);

                    data.SelectionStart = data.CursorPos;
                    data.SelectionEnd = data.CursorPos;
                    data.BufDirty = true;
                }
            }
        }
    }

    return 0;
}

#scope_file

make_ImVec2 :: inline (a: float, b: float) -> ImGui.ImVec2 {
    v: ImGui.ImVec2 = ---;
    v.x = a;
    v.y = b;
    return v;
}