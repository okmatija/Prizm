Command_Info :: struct {
    name : string;
    usage : string;
    documentation : string;
    procedure : ([]Any) -> (); // This will be the *_boiler_plate procedure generated by the meta-program
}

Console :: struct {
    history : [..]string; // Different to log in that command feedback is not stored in the history
    history_position : int = -1; // -1: new line, 0..history.count-1 browsing history
    commands : [..]Command_Info;
    log : [..]string;
    input_buffer : [256]u8;

    Log_Mode :: enum {
        INTERACTIVE;
        TRANSPARENT;
    }

    log_mode := Log_Mode.TRANSPARENT;
    scroll_to_bottom := true;
    scroll_to_bottom_frame_count := SCROLL_TO_BOTTOM_FRAME_INIT;

    show_ui := false;
}

// @Incomplete If the message is already present in the log don't add it again... in all cases?
console_logger :: (message: string, data: *void, info: Log_Info) {
    console_log := cast(*[..]string) data;
    if info.common_flags & .ERROR {
        array_add(console_log, join("[error] ", message));
        app.console.show_ui = true;
    } else if info.common_flags & .WARNING {
        array_add(console_log, join("[warning] ", message));
    } else {
        array_add(console_log, copy_string(message));
    }
    if app.console.scroll_to_bottom {
        app.console.scroll_to_bottom_frame_count = SCROLL_TO_BOTTOM_FRAME_INIT;
    }
}

// Clear all the text shown in the console
console_log_clear :: () {
    for app.console.log free(it);
    array_reset(*app.console.log);
} @RegisterCommand

console_add_history :: (format_string: string, args: .. Any) {
    builder: String_Builder;
    defer free_buffers(*builder);

    print_to_builder(*builder, format_string, ..args);

    text := builder_to_string(*builder);

    // Insert into history. First find match and delete it so it can be pushed to the back.
    for app.console.history {
        if equal_nocase(text, it) {
            remove it;
            break;
        }
    }
    array_add(*app.console.history, text);
} @PrintLike

console_save_history :: () {
    push_allocator(temp);
    history_string : string = join(..app.console.history, separator="\n");
    write_entire_file("console_history.txt", history_string);
}

console_load_history :: () {
    console_history_file, ok := read_entire_file("console_history.txt", zero_terminated=true, log_errors=false);
    if ok {
        file_lines := split(console_history_file, "\n");
        for file_lines {
            if trim(it, " ") != "" {
                console_add_history(it);
            }
        }
    } else {
        // log("Could not load console history from 'console_history.txt' file");
    }
}

// Clear the history of console commands
console_history_clear :: () {
    for app.console.history free(it);
    array_reset(*app.console.history);
    console_save_history();
} @RegisterCommand

console_execute_command :: (_command : string) -> success : bool {
    return false;
}

console_draw :: () {
    if !app.console.show_ui {
        return;
    }

    window_pivot := ImGui.ImVec2.{0, 1}; // SetNextWindowPos will refer to the bottom left corner of the window
    input_window_height : float = -1;
    scroll_delta_request : float;

    ImGui.PushStyleVar(xx ImGui.StyleVar.WindowRounding, 0);
    ImGui.PushStyleVar(xx ImGui.StyleVar.PopupRounding, 0);
    defer ImGui.PopStyleVar();
    defer ImGui.PopStyleVar();

    // Draw input window
    {
        console_top_y := app.current_window_height * .6;
        ImGui.SetNextWindowPos(ImGui.ImVec2.{0, xx app.current_window_height}, pivot=window_pivot);
        ImGui.SetNextWindowSize(ImGui.ImVec2.{xx app.current_window_width, -1}, .Always);

        window_flags := ImGui.WindowFlags.NoTitleBar | .NoResize | .NoDecoration;
        ImGui.Begin("console_input", flags=window_flags); // TODO if !Begin should close
        defer ImGui.End();

        ImGui.PushItemWidth(-65); // Set to leave space for UI to the right of the text input @Cleanup This is a bit crappy
        text_input_flags :=  ImGui.InputTextFlags.EnterReturnsTrue | .CallbackCompletion | .CallbackHistory;
        reclaim_focus := ImGui.IsWindowAppearing();
        if (ImGui.InputText(imgui_label("##Input", *app.console), app.console.input_buffer.data, app.console.input_buffer.count, text_input_flags, text_edit_callback, *app.console)) {
            defer app.console.input_buffer[0] = 0; // Wipe input after processing
            buffer := to_string(app.console.input_buffer.data, c_style_strlen(app.console.input_buffer.data));
            console_execute_command(buffer);
            reclaim_focus = true;
        }
        ImGui.PopItemWidth();

        // @Refactor Make this type of tooltip a reusable function
        if ImGui.IsItemHovered(.DelayNormal) {
            ImGui.BeginTooltip();
            ImGui.BeginTable(imgui_label("##InputTooltipTable", *app.console), 3, flags=ImGui.TableFlags.NoBordersInBody);

            ImGui.TableNextRow(); ImGui.TableNextColumn();
            ImGui.TextColored(app.theme.keymap_color, "TAB");
            ImGui.TableNextColumn();
            ImGui.Text("List commands and documentation");

            ImGui.TableNextRow(); ImGui.TableNextColumn();
            ImGui.TextColored(app.theme.keymap_color, "ESC/`");
            ImGui.TableNextColumn();
            ImGui.Text("Hide/Toggle console");

            ImGui.TableNextRow(); ImGui.TableNextColumn();
            ImGui.TextColored(app.theme.keymap_color, "UP/DOWN");
            ImGui.TableNextColumn();
            ImGui.Text("Navigate command history");

            ImGui.TableNextRow(); ImGui.TableNextColumn();
            ImGui.TextColored(app.theme.keymap_color, "Scroll");
            ImGui.TableNextColumn();
            ImGui.Text("Scroll the console log");

            ImGui.EndTable();
            ImGui.EndTooltip();

            // Negative so scrolling works as it does when hovering the scrollable region when the using INTERACTIVE mode
            scroll_delta_request = -30 * io().MouseWheel;
        }

        // Keeping auto focus on the input box after command is entered
        if reclaim_focus {
            ImGui.SetKeyboardFocusHere(-1); // Auto focus previous widget
        }

        ImGui.SameLine();

        if ImGui.Button("Options") {
            ImGui.OpenPopup("console_options");
        }

        if ImGui.BeginPopup("console_options") {

            is_interactive := app.console.log_mode == .INTERACTIVE;

            if ImGui.Checkbox("Interactive Log", *is_interactive) {
                app.console.log_mode = ifx is_interactive then Console.Log_Mode.INTERACTIVE else .TRANSPARENT;
                ImGui.CloseCurrentPopup();
            }

            if ImGui.Checkbox("Scroll to bottom", *app.console.scroll_to_bottom) {
                ImGui.CloseCurrentPopup();
            }

            if ImGui.Button("Save to LOG.txt") {
                contents : string;
                defer free(contents); // @Leaks the intermediate allocations!?
                time := filetime_to_readable_date(current_time_consensus(), true);
                contents = join(contents, tprint("This console log was saved at % via a button in the Prizm application\n", time));
                contents = join(contents, "Press '`' to open the console and find the button in the Options menu\n\n\n\n");
                for app.console.log {
                    contents = join(contents, it, separator="\n");
                }
                write_entire_file_to_cwd("LOG.txt", contents);
            }
            show_tooltip("Write the console log to LOG.txt\nHandy if you want to search the console log");
            ImGui.EndPopup();
        }

        input_window_height = ImGui.GetWindowHeight();
    }

    // Draw output window
    // @Incomplete Make the text selectable in INTERACTIVE mode
    if app.console.log.count != 0 {

        window_flags := ImGui.WindowFlags.NoTitleBar | .NoResize | .NoDecoration;
        if app.console.log_mode == .TRANSPARENT {
            window_flags |= .NoBringToFrontOnFocus; // Prioritize drawing item list if it covers the console
            window_flags |= .NoInputs;              // So we can interact with the scene behind the console output window
            window_flags |= .NoFocusOnAppearing;    // So we dont clobber the reclaim_focus stuff in the console input window
            window_flags |= .NoBackground;          // Makes the console log transparent
        }

        // The + 20 is just a bit extra that we need, + 1 because... well, something is fishy
        console_height := min(ImGui.GetFontSize() * (app.console.log.count + 1) + 20, app.current_window_height * .4);
        ImGui.SetNextWindowPos(ImGui.ImVec2.{0, xx (app.current_window_height - input_window_height)}, pivot=window_pivot);
        ImGui.SetNextWindowSize(ImGui.ImVec2.{xx app.current_window_width, xx console_height}, .Always);

        ImGui.Begin("console_output", flags=window_flags); // TODO if !Begin should close
        scrolling_region_flags := ImGui.WindowFlags.HorizontalScrollbar;
        if app.console.log_mode == .TRANSPARENT {
            scrolling_region_flags |= .NoInputs;   // So we can interact with the scene behind the console output window
            scrolling_region_flags |= .NoScrollbar; // Save some screenspace since we wont be interacting with the console log anyway
        }

        ImGui.BeginChild("ScrollingRegion", border=false, flags=scrolling_region_flags);
        ImGui.PushStyleVar(.ItemSpacing, ImGui.ImVec2.{4,1}); // Tighten spacing

        for :ListClipperIterator item : app.console.log {

            assert(item.count != 0);
            col := ifx app.console.log_mode == .INTERACTIVE then app.theme.console_interactive_text_color else app.theme.console_transparent_text_color;
            if begins_with(item, "#") {
                col = ifx app.console.log_mode == .INTERACTIVE then CONSOLE_COMMENT_INTERACTIVE else CONSOLE_COMMENT_TRANSPARENT;
            } else if begins_with(item, "|") {
                col = ifx app.console.log_mode == .INTERACTIVE then CONSOLE_DOCUMENTATION_INTERACTIVE else CONSOLE_DOCUMENTATION_TRANSPARENT;
            } else if begins_with(item, "[warning]") {
                col = ifx app.console.log_mode == .INTERACTIVE then CONSOLE_WARNING_INTERACTIVE else CONSOLE_WARNING_TRANSPARENT;
            } else if begins_with(item, "[error]") {
                col = ifx app.console.log_mode == .INTERACTIVE then CONSOLE_ERROR_INTERACTIVE else CONSOLE_ERROR_TRANSPARENT;
            }
            ImGui.TextColored(col, "%", item);
        }
        ImGui.PopStyleVar();

        if app.console.scroll_to_bottom_frame_count != 0 {
            ImGui.SetScrollY(ImGui.GetScrollMaxY());
            app.console.scroll_to_bottom_frame_count -= 1;
        }

        if scroll_delta_request != 0 {
            ImGui.SetScrollY(ImGui.GetScrollY() + scroll_delta_request);
        }

        ImGui.EndChild();

        ImGui.End();
    }
}

#scope_file

print_location :: (loc := #caller_location) {
    print("%:%\n", loc.fully_pathed_filename, loc.line_number);
}

text_edit_callback :: (data : *ImGui.InputTextCallbackData) -> s32 #c_call {

    new_context : Context;
    new_context.logger = console_logger;
    new_context.logger_data = *app.console.log;
    push_context new_context {

        // We pass *app.console as user data but use it directly since its global... whatever
        assert(cast(*void) data.UserData == cast(*void) *app.console);

        if data.EventFlag == {
            case .CallbackCompletion; {

                // Only complete the function name
                current_input := to_string(data.Buf, data.CursorPos);
                if contains(trim(current_input), " ") {
                    return 0;
                }

                // Locate beginning of current word
                word_end := data.Buf + data.CursorPos;
                word_start := data.Buf + trim_right(current_input, " ").count;
                while word_start > data.Buf {
                    c := (word_start - 1).*;
                    if (c == #char " " || c == #char "\t" || c == #char "," || c == #char ";")
                        break;
                    word_start -= 1;
                }

                current_word := to_string(word_start, word_end - word_start);
                // print("current_word = '%'\n", current_word);

                // Build a list of candidates
                candidates : [..]Command_Info;
                candidates.allocator = temp;
                for app.console.commands {
                    if begins_with_nocase(it.name, current_word) {
                        array_add(*candidates, it);
                    } else if it.name == trim_right(current_word) {
                        // Handles case when current_word has trailing spaces
                        array_add(*candidates, it);
                    }
                }

                if candidates.count == 0 {
                    // No match
                    console_log_clear();
                    log("# 0 matching commands. Did you forget the @RegisterCommand note?");

                } else if candidates.count == 1 {
                    // Single match. Delete the beginning of the word and replace it entirely so we've got nice casing
                    data.DeleteChars(data, xx (word_start - data.Buf), xx (word_end - word_start));
                    data.InsertChars(data, data.CursorPos, candidates[0].name);
                    data.InsertChars(data, data.CursorPos, " ");

                    // List matches
                    console_log_clear();
                    for candidate : candidates {
                        doc_lines := split(candidate.documentation, "\n");
                        for line : doc_lines log("%", line);
                    }
                } else {
                    // Multiple matches. Complete as much as we can

                    cursor : s32 = xx (word_end - word_start);
                    while true {

                        cursor_character : u8;
                        all_candidates_match := true;
                        for candidate, candidate_index : candidates {
                            if all_candidates_match == false {
                                break;
                            }

                            if cursor == candidate.name.count {
                                all_candidates_match = false;
                            } else if candidate_index == 0 {
                                cursor_character = to_upper(candidates[0].name[cursor]);
                            } else if cursor_character != to_upper(candidate.name[cursor]) {
                                all_candidates_match = false;
                            }
                        }

                        if !all_candidates_match {
                            break;
                        }

                        cursor += 1;
                    }

                    if cursor > 0 {
                        data.DeleteChars(data, xx (word_start - data.Buf), xx (word_end - word_start));
                        tmp := slice(candidates[0].name, 0, cursor);
                        data.InsertChars(data, data.CursorPos, tmp);
                    }

                    // List matches
                    console_log_clear();
                    log("# % matching commands:", candidates.count);
                    for candidate : candidates{
                        log("#  %", candidate.usage);
                    }
                }
            }

            case .CallbackHistory; {

                prev_history_position := app.console.history_position;
                if data.EventKey == .UpArrow {
                    if app.console.history_position == -1 {
                        app.console.history_position = app.console.history.count - 1;
                    } else if app.console.history_position > 0 {
                        app.console.history_position -= 1;
                    }
                } else if data.EventKey == .DownArrow {
                    if app.console.history_position != -1 {
                        app.console.history_position += 1;
                        if app.console.history_position >= app.console.history.count {
                            app.console.history_position = -1;
                        }
                    }
                }

                // A better implementation would preserve the data on the current input line along with cursor position.
                if prev_history_position != app.console.history_position {

                    if app.console.history_position >= 0 {
                        item := app.console.history[app.console.history_position];
                        data.CursorPos = xx item.count;
                        memcpy(data.Buf, item.data, item.count);
                        data.Buf[item.count] = 0;
                        data.BufTextLen = xx item.count;
                    } else {
                        data.CursorPos = 0;
                        data.Buf[0] = 0;
                        data.BufTextLen = 0;
                    }

                    assert(c_style_strlen(data.Buf) == data.BufTextLen);

                    data.SelectionStart = data.CursorPos;
                    data.SelectionEnd = data.CursorPos;
                    data.BufDirty = true;
                }
            }
        }
    }

    return 0;
}

#scope_file

// ImGui.SetScrollY needs to be called in two consecutive frames to scroll to the bottom of the console
// perhaps this isn't needed, or is a bug in ImGui? @Cleanup
SCROLL_TO_BOTTOM_FRAME_INIT :: 2;
